input AddPackageToShipmentBatchInput {
  batch_id: ID!
  package_id: ID!
}

type Address {
  id: ID!
  description: String
  name: String
  first_name: String
  last_name: String
  phone: String
  cell_phone: String
  email: String
  company: String
  address_1: String
  address_2: String
  address_3: String
  city: String
  state: String
  zip: String
  country: String
  validated: Boolean!
  residential: Boolean!
  contacts: [Contact]
  deals: [Deal]
  orders: [Order]
  vendors: [Vendor]
  receivingLocations: [ReceivingLocation]
  purchaseOrders: [PurchaseOrder]
  isValidToShip(
    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): Boolean!
  isValidToShipMessages(
    """Whether or not we should bail on the first found error."""
    bailEarly: Boolean = false

    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): [ValidationMessage!]!
  isValidForShipping: Boolean! @deprecated(reason: "Replaced by isValidToShip.")
  isValidForShippingMessages: [String!]! @deprecated(reason: "Replaced by isValidToShipMessages.")
  audits: [Audit!]!
}

input AddressCreateInput {
  description: String
  first_name: String
  last_name: String
  phone: String
  cell_phone: String
  email: String
  company: String
  address_1: String
  address_2: String
  address_3: String
  city: String
  state: String
  zip: String
  country: String
  orders: AddressUpdateRelation
  contacts: AddressUpdateRelation
  vendors: AddressUpdateRelation
  receivingLocations: AddressUpdateRelation
  deals: AddressUpdateRelation
  purchaseOrders: AddressUpdateRelation
  validated: Boolean
  residential: Boolean
}

input AddressFilter {
  ids: [ID]
}

input AddressUpdateInput {
  id: ID!
  description: String
  first_name: String
  last_name: String
  phone: String
  cell_phone: String
  email: String
  company: String
  address_1: String
  address_2: String
  address_3: String
  city: String
  state: String
  zip: String
  country: String
  validated: Boolean
  residential: Boolean
  orders: AddressUpdateRelation
  contacts: AddressUpdateRelation
  vendors: AddressUpdateRelation
  receivingLocations: AddressUpdateRelation
  deals: AddressUpdateRelation
  purchaseOrders: AddressUpdateRelation
}

input AddressUpdateRelation {
  disconnect: [ID]
  connect: [ID]
  sync: [ID]
}

type ApiKey {
  id: ID!
  name: String!
  api_key: String!
  user_id: ID!
  revoked: Boolean!
  created_at: DateTime!
  updated_at: DateTime
  user: User!
}

input ApiKeyCreateInput {
  name: String
  user_id: ID!
}

input ApiKeyUpdateInput {
  id: ID!
  revoked: Boolean
}

type AppLog {
  id: ID!
  context_id: ID
  user_id: ID
  flag: Boolean!
  message: String!
  context: JSON!
  level: Int!
  level_name: String!
  channel: String!
  record_datetime: DateTime!
  extra: String!
  formatted: String!
  remote_address: String
  user_agent: String
  created_at: DateTime!
  User: User
}

"""A paginated list of AppLog items."""
type AppLogPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of AppLog items."""
  data: [AppLog!]!
}

input AppLogUpdateInput {
  id: ID!
  flag: Boolean!
}

input AppLogsInput {
  ids: [Int!]
  user_id: ID
  formatted: String
  context_id: String
  levels: [Int!]
  flag: Boolean
  from: DateTime
  to: DateTime
}

type AppLogsSummary {
  debug: Int!
  info: Int!
  notice: Int!
  error: Int!
  critical: Int!
  alert: Int!
  emergency: Int!
  total: Int!
}

type AppLogsSummaryByUser {
  user_id: ID
  total: Int!
  debug: Int!
  info: Int!
  notice: Int!
  error: Int!
  critical: Int!
  alert: Int!
  emergency: Int!
  User: User
}

input AppLogsSummaryInput {
  from: DateTime
  to: DateTime
}

type AppSetting {
  id: ID!
  key: String!
  value: JSON!
  description: String
  created_at: DateTime!
  updated_at: DateTime
}

type Attribute {
  id: ID!
  name: String!
  filterable: Boolean!
  applies_to_variations: Boolean!
  products: [Product!]!
  options: [AttributeOption!]!
}

input AttributeFilter {
  ids: [ID]
  name: String
  filterable: Boolean
  applies_to_variations: Boolean
  orderBy: [OrderByClause!]
}

type AttributeOption {
  id: ID!
  name: String!
  products: [Product!]!
  attribute: Attribute!
  attribute_id: ID!
}

input AttributeOptionFilter {
  ids: [ID]
  name: String
  attribute_id: ID
}

"""A paginated list of Attribute items."""
type AttributePaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Attribute items."""
  data: [Attribute!]!
}

type Audit {
  id: ID!
  user_type: String!
  user_id: String
  event: String!
  auditable_type: String!
  auditable_id: ID!
  old_values: JSON!
  new_values: JSON!
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
  user: User
}

input AuditCreateInput {
  user_type: String!
  event: String!
  auditable_type: String
  auditable_id: ID
  old_values: JSON!
  new_values: JSON!
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
}

input AuditFilter {
  ids: [ID!]
}

input AuditUpdateInput {
  user_type: String!
  event: String!
  auditable_type: String
  auditable_id: ID
  old_values: JSON
  new_values: JSON
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
}

type AuthPayload {
  access_token: String
  refresh_token: String
  expires_in: Int
  token_type: String
  user: User
}

type AutocalculatePackage {
  package_id: ID!
  order_id: ID
  weight: Int!
  length: Int!
  height: Int!
  width: Int!
  box_type: PackageType!
  has_LED: Boolean
  has_SS: Boolean
}

type Brand {
  id: ID!
  name: String!
}

type Building {
  id: ID!
  name: String!
  color: String!
}

input BuildingFilter {
  id: String
  ids: [ID]
  name: String
}

input BulkOrderItemExceptionCloseInput {
  """
  The ID of the order we're applying this to. Required if `orderNumber` not present.
  """
  orderId: ID

  """
  The number of the order we're applying this to. Required if `orderId` not present.
  """
  orderNumber: ID

  """The product ID we will be using to bucket fill."""
  productId: ID!

  """
  The finish option ID we will be using to bucket fill (if null is supplied, will only find items that have production
  items and a finish option ID of `null`.
  """
  finishOptionId: ID

  """Exception reason ID to apply when creating the exception."""
  reasonId: ID!

  """The quantity we should bucket fill against."""
  quantity: Int!

  """
  Whether we should reset all production steps for the associated production item.
  """
  resetProductionSteps: Boolean
}

input BulkOrderItemExceptionOpenInput {
  """
  The ID of the order we're applying this to. Required if `orderNumber` not present.
  """
  orderId: ID

  """
  The number of the order we're applying this to. Required if `orderId` not present.
  """
  orderNumber: ID

  """The product ID we will be using to bucket fill."""
  productId: ID!

  """
  The finish option ID we will be using to bucket fill (if null is supplied, will only find items that have production
  items and a finish option ID of `null`.
  """
  finishOptionId: ID

  """Exception reason ID to apply when creating the exception."""
  reasonId: ID!

  """The quantity we should bucket fill against."""
  quantity: Int!

  """
  The production item step that we should use for filtering context. Will EXCLUDE any items with this step already
  complete. For example, if you're creating bulk exceptions on a 'in_process_metal' cell, you would use
  IN_PROCESS_METAL here so we do not accidentally open exceptions on lineitems that are complete in this cell.
  """
  productionStep: ProductionItemStepColumn!

  """Notes to be added to one or more of the exceptions."""
  additionalNotes: String
}

input BulkShipInput {
  id: ID!
  options: ShipmentOptions
  processorOptions: ShipmentProcessorOptions
}

type Bundle {
  id: ID!
  product: Product
  product_id: ID
  bundleProduct: Product
  bundle_product_id: ID
  bundleGroup: BundleGroup
  bundle_group_id: ID
  bundleType: BundleType
  bundle_type_id: ID!
  quantity: Int!
}

type BundleGroup {
  id: ID!
  name: String!
  products: [Product!]!
}

input BundleGroupFilter {
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of BundleGroup items."""
type BundleGroupPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of BundleGroup items."""
  data: [BundleGroup!]!
}

input BundleGroupProductsRelation {
  sync: [ID!]
  disconnect: [ID!]
}

type BundleRule {
  id: ID!
  product: Product
  product_id: ID
  options: [AttributeOption!]!
  ruleProducts: [BundleRuleProduct!]!
}

input BundleRuleOptionsRelation {
  connect: [ID]
  disconnect: [ID]
  sync: [ID]
}

type BundleRuleProduct {
  id: ID!
  bundleRule: BundleRule
  bundle_rule_id: ID
  bundleType: BundleType
  bundle_type_id: ID
  product: Product
  product_id: ID
  bundle_product_id: ID
  bundleProduct: Product
}

input BundleRuleProductsRelation {
  connect: [ID]
  create: [CreateBundleRuleProductInput!]
  update: [UpdateBundleRuleProductInput!]
  delete: [ID!]
  disconnect: [ID]
  sync: [ID]
}

type BundleType {
  id: ID!
  name: String
}

enum ChargeType {
  Amazon
  Cash
  Check
  CreditCard
  FreeSample
  Mixed
  NoChargeRemake
  PayPal
  WireTransfer
}

type Company {
  id: ID!
  name: String!
  contacts: [Contact!]!
}

input CompanyCreateInput {
  name: String!
}

input CompanyFilter {
  ids: [ID!]
  name: String
}

"""A paginated list of Company items."""
type CompanyPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Company items."""
  data: [Company!]!
}

input CompanyUpdateInput {
  id: ID!
  name: String
}

type CompleteWoodSampleSteps {
  production_item_ids: [ID!]!
}

type CompleteWoodSteps {
  production_item_ids: [ID!]!
  steps: [ProductionItemStepColumn!]!
}

type CompletedServices {
  id: ID!
  service_id: ID!
  user_id: ID
  quantity: Int!
  created_at: DateTime
  updated_at: DateTime
}

type Contact {
  id: ID!
  hubspot_id: ID
  first_name: String
  last_name: String
  email: String
  company_id: ID
  owner_id: ID
  customer_type_id: ID
  brand_id: ID
  phone: String
  tax_exemption_number: String
  primary_address: ID
  created_at: DateTime
  updated_at: DateTime
  addresses: [Address!]!
  brand: Brand
  company: Company
  customerType: CustomerType
  fileable: Fileable!
  files: [File!]!
  owner: User
  primaryAddress: Address
  name: String!
}

input ContactAddressRelation {
  create: [AddressCreateInput!]
  upsert: [AddressUpdateInput!]
  sync: [ID!]
  connect: [ID!]
}

input ContactCreateInput {
  hubspot_id: ID
  first_name: String
  last_name: String
  email: String
  company_id: ID
  owner_id: ID
  customer_type_id: ID!
  brand_id: ID
  phone: String
  primary_address: String
  tax_exemption_number: String
  addresses: ContactAddressRelation
}

input ContactFilter {
  ids: [ID]
  first_name: String
  last_name: String
  email: String
}

"""A paginated list of Contact items."""
type ContactPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Contact items."""
  data: [Contact!]!
}

input ContactUpdateInput {
  id: ID!
  hubspot_id: ID
  first_name: String
  last_name: String
  email: String
  company_id: ID
  owner_id: ID
  customer_type_id: ID
  brand_id: ID
  phone: String
  primary_address: String
  tax_exemption_number: String
  addresses: ContactAddressRelation
}

input CopyAddressToOrdersInput {
  addressId: ID!
  contactId: ID!
  setBilling: Boolean
  setShipping: Boolean
  setFinalShipping: Boolean
}

type CostAccount {
  id: ID!
  name: String!
  vendorParts: [VendorPart!]!
}

input CostAccountFilter {
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of CostAccount items."""
type CostAccountPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of CostAccount items."""
  data: [CostAccount!]!
}

enum CountryCode {
  US
}

"""
Input type to handle processing of transactions. Requires one of the payment methods (credit_card, etc).
"""
input CreateAndProcessTransactionInput {
  transaction: TransactionCreateInput!
  credit_card_transaction: ProcessCreditCardTransactionInput
}

input CreateAttributeInput {
  name: String
  filterable: Boolean
  applies_to_variations: Boolean
  options: UpdateAttributeOptionsRelation
}

input CreateAttributeOptionInput {
  name: String!
  attribute_id: ID!
}

input CreateBuildingInput {
  name: String!
  color: String!
}

input CreateBundleGroupInput {
  name: String!
  products: BundleGroupProductsRelation
}

input CreateBundleInput {
  product_id: ID
  bundle_product_id: ID
  bundle_group_id: ID
  bundle_type_id: ID!
  quantity: Int!
}

input CreateBundleRuleInput {
  product_id: ID
  options: BundleRuleOptionsRelation
  ruleProducts: BundleRuleProductsRelation
}

input CreateBundleRuleProductInput {
  product_id: ID
  bundle_rule_id: ID
  bundle_type_id: ID
  bundle_product_id: ID
}

input CreateCostAccountInput {
  name: String!
}

input CreateDepartmentInput {
  name: String!
}

input CreateDimensionInput {
  length: Float
  width: Float
  height: Float
  unit_weight: Float
}

input CreateFinishGroupInput {
  name: String!
  active: Boolean!
  finishOptions: FinishGroupFinishOptionRelation
}

input CreateFinishOptionInput {
  name: String!
  description: String
  victor_name: String
  finish_multiplier: Float!
  is_prime: Boolean!
  is_stain: Boolean!
  is_clear: Boolean!
  is_outsourced: Boolean!
  block_order_release: Boolean!
  archived: Boolean!
  finishGroups: FinishOptionFinishGroupRelation
}

input CreateGlobalSaleInput {
  start_date: DateTime!
  end_date: DateTime!
  sale_percent: Float!
}

input CreateInventoryInput {
  bin_qty: Int
  bin_count: Int
  inventory_type: InventoryType
  is_hpc: Boolean
  is_prepackaged: Boolean
  kanban_bin_location: String
  pick_to_light_device_id: String
}

input CreateItemExceptionInput {
  reason_id: ID!
  quantity: Int!
  order_line_item_id: ID
  production_item_id: ID
  additional_notes: String
}

input CreateLocationInput {
  name: String!
  parent_id: ID
}

input CreateManufacturingAttribute {
  key: String
  datatype: String
  level: String
}

input CreateManufacturingAttributeOption {
  value: String
  manufacturing_attribute_id: ID!
}

input CreateManufacturingInput {
  process_time: Int
  buffer_time: Int
  cnc_program: String
  production_data: JSON
}

input CreateMaterialInput {
  name: String!
  product_name: String
  material_type_id: ID!
  finish_group_id: ID
  active: Boolean
  MaterialSizes: MaterialSizeRelation
}

input CreateMaterialLengthInput {
  name: String!
  active: Boolean!
  material_type_id: ID!
  unit_of_measure_id: ID!
}

input CreateMaterialSizeInput {
  name: String!
  material_type_id: ID
  sort: Int
  active: Boolean
}

input CreateMaterialTypeInput {
  name: String!
  active: Boolean
}

input CreateNoteInput {
  content: String!
  tags: NoteTagRelation!
  deals: NoteDealsRelation
  orders: NoteOrdersRelation
  lineItems: NoteLineItemsRelation
  user_id: ID
}

input CreateOD1ProductTypeGroupInput {
  name: String!
  od1_parent_group_id: ID
  active: Boolean
}

input CreateOrderGroupInput {
  name: String!
  sort: Int
}

input CreateOrderLineItemGroupInput {
  name: String!
  sort: Int
  items: OrderLineItemGroupItemsRelation
}

input CreateOrderProductTypeGroupScheduleInput {
  order_id: ID!
  od1_product_type_group_id: ID!
  production_date: Date!
}

input CreateOrderRemake {
  order_id: ID
  from_order_id: ID!
  remake_notes: String!
  order: OrderRemakeOrderRelationInput
  reasons: OrderRemakeReasonRelationInput
  lineItems: OrderRemakeLineItemRelationInput
}

input CreateOrderRemakeReason {
  order_remake_id: ID!
  remake_process_id: ID
  remake_reason_id: ID
  remake_sub_reason_id: ID
}

input CreateOrderRemakeReasonRelation {
  remake_process_id: ID
  remake_reason_id: ID
  remake_sub_reason_id: ID
}

input CreatePackingBayInput {
  name: String!
}

input CreatePermissionInput {
  name: String!
}

input CreatePieceInput {
  product_id: ID!
  piece_product_id: ID!
  quantity: Int!
}

input CreatePiecePackInput {
  product_id: ID!
  piece_pack_product_id: ID!
  quantity: Int!
}

input CreatePostBracketInput {
  name: String!
  active: Boolean
}

input CreatePostTopStyleInput {
  name: String!
  active: Boolean
  post_bracket_id: ID
  post_top_type_id: ID
  material_id: ID
}

input CreatePostTopTypeInput {
  name: String!
  active: Boolean
}

input CreatePricingTierInput {
  product_id: ID!
  tier_weight: Float
  tier_number: Int
  options: PricingTierOptionsRelation
}

input CreateProductCustomization {
  name: String!
  name_suffix: String!
  description_prefix: String!
  additional_price: Float!
  additional_labor_cost: Float!
  archived: Boolean!
  accounting_type_id: ID!
  od1ProductTypes: ProductCustomizationOd1ProductTypeRelation
}

input CreateProductFamilyInput {
  name: String
  process_time: Int
  buffer_time: Int
  customization_prefix: String
  dropship: Boolean
  customizable: Boolean
  discountable: Boolean
  deleted_at: DateTime
  product_type_id: ID
  features: ProductFeatureRelation
}

input CreateProductFeature {
  name: String!
  name_suffix: String
  description: String!
  additional_price: Float!
  additional_labor_cost: Float!
  post_cnc_program_suffix: String
  od1_accounting_type_id: String
  name_suffix_price_sync: String
  active: Boolean
  od1ProductTypes: ProductFeatureOd1ProductTypeRelation
}

input CreateProductGroupInput {
  name: String
  process_time: Int
  buffer_time: Int
  engineering_lead_time: Int
}

input CreateProductInput {
  name: String!
  customer_product_name: String
  customer_product_description: String
  description: String
  price: Float!
  sale_price_percent: Float
  purchase_price: Float
  purchase_price_included_products: Float
  labor_cost: Float
  can_have_finish: Boolean
  pre_finish_cost: Float
  finish_price: Float
  instructions: String
  is_present_on_stairsupplies: String
  is_present_on_viewrail: String
  viewrail_image_url: String
  viewrail_slug: String
  stairsupplies_image_url: String
  stairsupplies_slug: String
  children_naming_scheme: String
  wood_dim_material_id_1: ID
  wood_dim_material_id_2: ID
  wood_dim_material_id_3: ID
  wood_dim_material_id_4: ID
  wood_dim_material_size_id_1: ID
  wood_dim_material_size_id_2: ID
  wood_dim_material_size_id_3: ID
  wood_dim_material_size_id_4: ID
  wood_dim_prc_chop_1: Float
  wood_dim_prc_chop_2: Float
  wood_dim_prc_chop_3: Float
  wood_dim_prc_chop_4: Float
  wood_dim_chop_quantity_1: Float
  wood_dim_chop_quantity_2: Float
  wood_dim_chop_quantity_3: Float
  wood_dim_chop_quantity_4: Float
  wood_dim_rip_width_1: Float
  wood_dim_rip_width_2: Float
  wood_dim_rip_width_3: Float
  wood_dim_rip_width_4: Float
  wood_dim_plane_thickness_1: Float
  wood_dim_plane_thickness_2: Float
  wood_dim_plane_thickness_3: Float
  wood_dim_plane_thickness_4: Float
  wood_dim_glue_type_1: String
  wood_dim_glue_type_2: String
  wood_dim_glue_type_3: String
  wood_dim_glue_type_4: String
  wood_dim_final_width_1: Float
  wood_dim_final_width_2: Float
  wood_dim_final_width_3: Float
  wood_dim_final_width_4: Float
  wood_dim_final_length_1: Float
  wood_dim_final_length_2: Float
  wood_dim_final_length_3: Float
  wood_dim_final_length_4: Float
  wood_dim_final_height_1: Float
  wood_dim_final_height_2: Float
  wood_dim_final_height_3: Float
  wood_dim_final_height_4: Float
  glass_base: Float
  glass_height: Float
  glass_number_of_slots: Float
  glass_number_of_holes: Float
  board_footage: Float
  classification: ProductClassification
  parent_id: ID
  lead_time: Int
  product_family_id: ID
  material_size_id: ID
  material_id: ID
  dimension: ProductDimensionRelation
  inventory: ProductInventoryRelation
  manufacturingAttributes: ProductManufacturingAttributeRelation
  manufacturing: ProductManufacturingRelation
  product_status: ProductStatus
  productionCharts: ProductProductionChartRelation
  purchasing_part: PurchasingPartRelation
  ship_as_freight: Boolean
  stringer_length: Float
  zero_price_when_mandatory: Boolean
  purchasing_vendor_part_number: String
  auto_convert_to_special_on_import: Boolean
  prevents_order_release: Boolean
  shipping_class: Float
  prepackaging_type: PrePackagingType
  raw_material_id: ID
  raw_material_qty_per_unit: Int
  finish_option_id: ID
  default_finish_option_id: ID
  finish_group_id: ID
  is_installation_kit: Boolean
  is_hpc: Boolean
  handrail_profile: String
  vr_part: String
  vendor_id: ID
  archived: Boolean
  stock_out: Boolean
  post_cnc_program: String
  post_foot_style_id: ID
  post_top_style_id: ID
  post_configuration: String
  suggestedProducts: ProductSuggestedGroupRelation
  suggestedGroups: ProductSuggestedGroupRelation
}

input CreateProductProductionChart {
  product_id: ID!
  thickness: Float
  length: Float
  depth: Float
  final_thickness: Float
  final_length: Float
  final_depth: Float
  chop_quantity: Float
  glue_type: String
}

input CreateProductSuggestedGroupInput {
  product_id: ID!
  product_suggestion_id: ID
  suggested_group_id: ID
  quantity: Int!
  mandatory: Boolean!
}

input CreateProductTypeInput {
  name: String
  enumerate: Boolean
  process_time: Int
  buffer_time: Int
  capacity: Int
  product_group_id: ID
}

input CreateProductionSchedulingGroupInput {
  name: String!
  capacity: Int!
  label: String
  od1ProductTypeGroupIds: [ID!]
}

input CreatePurchaseOrderInput {
  purchase_order_status: PurchaseOrderStatus!
  created_by_id: ID!
  purchase_order_notes: String
  shipping_cost: Float
  item_tax: Float
  due_date: Date
  vendor_id: ID!
  lineItems: PurchaseOrderLineItemRelation
}

input CreatePurchaseOrderLineItemInput {
  purchase_order_id: ID
  vendor_part_id: ID
  name: String
  description: String
  vendor_sku: String
  cost_account_id: ID
  department_id: ID

  """quantity: Int"""
  purchase_price: Float
  reorder_quantity: Int
  requested_by_id: ID
  requested_quantity: Int
  received_quantity: Int
}

input CreatePurchasingPartInput {
  name: String
  description: String
  product_id: ID
  vendorParts: VendorPartRelation
}

input CreatePurchasingPartRequestInput {
  requested_by_id: ID!
  requested_quantity: Int!
  requested_on: Date!
  requested_status: RequestedPartStatus!
  purchasing_part_id: ID
  description: String
  purchase_price: Float
  due_date: Date!
}

input CreateRGARequestInput {
  order_id: ID!
  number_of_packages: Int!
  rga_return_reason_id: ID = 6
  details: String!
  items: [RGAFormRequestItemInput!]!
  files: [Upload!]!
}

input CreateRawMaterialInput {
  name: String!
  cost: Float!
  active: Boolean!
}

input CreateReceivingLocationInput {
  name: String!
}

input CreateRoleInput {
  name: String!
  permissions: PermissionRuleRelation
}

input CreateShipmentBatchFromPackagesInput {
  packages: ShipmentBatchPackageRelation!
  shipping_method: ID!
  vrd_import_location_id: ID
  options: ShipmentOptions
  processorOptions: ShipmentProcessorOptions
  ship_now: Boolean = false
}

input CreateShipmentBatchInput {
  shipping_method_id: ID!
  vrd_import_location_id: ID
  shipments: ShipmentBatchShipmentRelation
}

input CreateShippingMethodInput {
  name: String!
  carrier: ShippingCarrier
  transport_class: TransportClass!
  next_day_air: Boolean!
  same_day: Boolean!
  active: Boolean!
}

input CreateSubAssemblyInput {
  name: String!
  order_line_item_id: ID
  production_item_id: ID
  parent_id: ID
  quantity: Int
  data: String
  instructions: String
}

input CreateSuggestedGroupInput {
  name: String!
  products: SuggestedGroupProductRelation
  suggestedGroupProducts: SuggestedGroupProductRelation
}

input CreateUnitOfMeasureInput {
  name: String!
  symbol: String!
  active: Boolean
}

input CreateUserInput {
  username: String!
  first_name: String!
  last_name: String!
  email: String!
  phone: String
  password: String!
  sales_team_id: ID
  roles: UserRoleRelation
  permissions: UserPermissionRelation
}

input CreateVendorInput {
  name: String!
  phone: String
  fax: String
  attention: String
  email: String
  terms: String
  purchasing_default_tax: Float
  purchasing_rules: String
  dropship: Boolean
  mfg: Boolean
}

input CreateVendorPartInput {
  vendor_id: ID!
  name: String
  description: String
  vendor_sku: String
  notes: String
  cost_account_id: ID
  department_id: ID
  purchase_price: Float
  purchasing_part_id: ID
  reorder_quantity: Int
}

input CustomerCreateAndProcessTransactionInput {
  order_id: ID!
  transaction: CustomerTransactionCreateInput!
  credit_card_transaction: ProcessCreditCardTransactionInput
}

input CustomerTransactionCreateInput {
  deal_id: ID!
  transaction_date: DateTime
  charge_type: ChargeType!
  amount: Float
}

type CustomerType {
  id: ID!
  name: String!
}

scalar Date

scalar DateTime

type Deal {
  id: ID!
  key: String!
  total: Float!
  job_name: String
  hubspot_id: ID
  orders: [Order!]!
  created_at: DateTime
  updated_at: DateTime
  sales_team_id: ID
  salesTeam: SalesTeam
  owner_id: ID
  owner: User
  notes: [Note!]!
  primary_contact_id: ID
  primaryContact: Contact
  contacts: [Contact!]!
  shipping_contact_id: ID
  shippingContact: Contact
  billing_contact_id: ID
  billingContact: Contact
  taxExemptContacts: [Contact!]! @deprecated(reason: "Not developed.")
  balance: Float! @deprecated(reason: "Not developed.")
  transactionsTotal: Float! @deprecated(reason: "Not developed.")
  transactions: [DealTransaction!]! @deprecated(reason: "Not developed.")
  fileableTree(relationTypes: [RelationType!]): FileableTreeNode
  notableTree(relationTypes: [RelationType!]): NotableTreeNode
}

input DealCreateInput {
  total: Float
  billing_contact_id: ID
  shipping_contact_id: ID
  primary_contact_id: ID
  job_name: String
  hubspot_id: ID
  sales_team_id: ID
  owner_id: ID
}

"""A paginated list of Deal items."""
type DealPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Deal items."""
  data: [Deal!]!
}

input DealSearchFilter {
  ids: [ID!]
  total: DealTotalRange
  job_name: String
  sales_team_id: ID
  owner_id: ID
  city: String
  state: String
  company_id: ID
  contact_ids: [ID!]
}

input DealTotalRange {
  from: Float
  to: Float
}

type DealTransaction {
  id: ID!
  deal_id: ID!
  deal: Deal!
  transaction_date: DateTime!
  charge_type: ChargeType!
  amount: Float!
  received: Boolean!
  canceled_on: DateTime
  canceled: Boolean!
  meta: JSON
  created_at: DateTime
  updated_at: DateTime
}

input DealUpdateContactRelation {
  create: [ContactCreateInput!]
  connect: [ID!]
  disconnect: [ID!]
  update: [ContactUpdateInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  delete: [ID!]
}

input DealUpdateInput {
  id: ID!
  total: Float
  job_name: String
  hubspot_id: ID
  sales_team_id: ID
  shipping_contact_id: ID
  billing_contact_id: ID
  primary_contact_id: ID
  owner_id: ID
  created_at: DateTime
  updated_at: DateTime
  contacts: DealUpdateContactRelation
  orders: DealUpdateOrderRelation
}

input DealUpdateOrderRelation {
  create: [OrderCreateInput!]
  update: [OrderUpdateInput!]
  delete: [ID!]
}

input DeleteOrderProductTypeGroupScheduleFilter {
  ids: [ID!]
  orders: [ID!]
}

input DeleteShipmentBatchInput {
  id: ID!
}

type DeliveryWindow {
  from: Date!
  to: Date!
}

input DeliveryWindowInput {
  zip: String!
  release_date: Date!
  product_ids: [Int!]!
}

type Department {
  id: ID!
  name: String!
  vendorParts: [VendorPart!]!
}

input DepartmentFilter {
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of Department items."""
type DepartmentPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Department items."""
  data: [Department!]!
}

type Dimension {
  product_id: ID!
  length: Float
  width: Float
  height: Float
  unit_weight: Float
  product: Product
}

type DistributionCenter {
  id: ID!
  name: String!
  slug: String!
  created_at: DateTime!
  updated_at: DateTime
  deleted_at: DateTime
  Address: Address
}

type DistributionCenterSetting {
  appSetting: AppSetting!
  selected: DistributionCenter
  options: [DistributionCenter!]!
}

input DropshipItem {
  id: ID!
  quantity: Int!
}

type EngineeringTask {
  id: ID!
  order_id: ID!
  depends_on: ID
  product_group_id: ID!
  productGroup: ProductGroup!
  step_id: ID!
  task_type: ID!
  due_date: Date!
  complete: Boolean!
  techComplete: Boolean!
  completed_by: ID
  completed_on: DateTime
  tech_completed_by: ID
  tech_completed_on: DateTime
  created_at: DateTime!
  updated_at: DateTime!
  order: Order!
  dependsOn: EngineeringTask
  dependants: [EngineeringTask!]!
  completedBy: User
  techCompletedBy: User
  notes: [Note!]!
  noteCount: Int!
  lineItems: [OrderLineItem!]!
  lineItemCount: Int!
}

input EngineeringTaskCreateInput {
  order_id: ID!
  depends_on: ID
  product_group_id: ID!
  step_id: ID!
  task_type: ID!
  due_date: Date!
  lineItems: UpdateEngineeringTaskProductsRelation
}

input EngineeringTaskFilter {
  order_id: ID
  include_complete: Boolean = false
  product_group_ids: [ID!]
  active_only: Boolean
  include_on_hold: Boolean = false
}

type EngineeringTaskStep {
  id: ID!
  name: String!
}

type EngineeringTaskType {
  id: ID!
  name: String!
}

input EngineeringTaskUpdateInput {
  id: ID!
  order_id: ID
  depends_on: ID
  product_group_id: ID
  step_id: ID
  task_type: ID
  due_date: Date
  lineItems: UpdateEngineeringTaskProductsRelation
}

type Epc {
  id: ID!
  code: String!
  production_item_id: ID!
}

input EpcCreateInput {
  code: String!
  production_item_id: String
}

enum ErrorLevel {
  info
  caution
  warning
  error
}

type ExceptionReason {
  id: ID!
  name: String!
}

type File {
  id: ID!
  name: String!
  display_name: String
  displayName: String!
  extension: String!
  alt_text: String
  mime_type: String
  has_thumbnail: Boolean!
  thumbnail_url: String
  download_permalink: String
  viewable_permalink: String
  url(
    """
    Whether or not we should generate this URL as download or view. Defaults to a 'view' in browser / embed URL.
    """
    download: Boolean = false

    """
    The time at which the URL should expire. This can be a Unix timestamp, a
    DateTime formatted string, or a string that can be evaluated by strtotime.
    Defaults to 20 minutes if not specified. Cannot be null.
    """
    expiration: Mixed = "+20 minutes"
  ): String!
  created_at: DateTime
  updated_at: DateTime
  groups: [FileGroup!]!
  tags: [Tag!]!
}

input FileCreateInput {
  name: String
  display_name: String
  alt_text: String
  mime_type: String
  has_thumbnail: Boolean
  created_at: DateTime
  updated_at: DateTime
  groups: FileGroupRelation
}

type FileGroup {
  id: FileGroupEnum!
  name: String!
}

enum FileGroupEnum {
  ENGINEERING
  INTERNAL
  CUSTOMER
  SHIPMENTS
  SHIPPING_LABEL
  SHIPPING_BOL
  PACKAGING
}

input FileGroupRelation {
  create: [FileCreateInput!]
  connect: [ID!]
  update: [FileUpdateInput!]
  disconnect: [ID!]
  sync: [ID!]
  delete: [ID!]
  syncWithoutDetaching: [ID!]
}

input FileUpdateInput {
  id: ID!
  name: String
  display_name: String
  alt_text: String
  mime_type: String
  has_thumbnail: Boolean
  created_at: DateTime
  updated_at: DateTime
  groups: FileGroupRelation
}

input FileUploadInput {
  files: [Upload!]!
  fileable_id: ID!
  fileable_type: RelationType!
  fileable_group: FileGroupEnum
  relatedTagIds: [ID!]
}

type Fileable {
  id: ID!
  relatedRecordId: ID!
  RelationType: RelationType!
  files: [File!]!
}

union FileableTreeModels = Deal | Order | OrderLineItem

type FileableTreeNode {
  id: ID!
  label: String!
  relationType: RelationType!
  fileable: Fileable
  model: FileableTreeModels!
  children: [FileableTreeNode!]
}

input FilterRGARequestsInput {
  reason: String
  order_id: ID
}

type FinishGroup {
  id: ID!
  name: String!
  active: Boolean!
  finishOptions: [FinishOption!]!
}

input FinishGroupFilter {
  ids: [ID]
  name: String
  active: Boolean
}

input FinishGroupFinishOptionRelation {
  connect: ID
  sync: [ID!]
  update: [UpdateFinishOptionInput!]
}

type FinishOption {
  id: ID!
  name: String!
  description: String
  victor_name: String
  finish_multiplier: Float!
  is_prime: Boolean!
  is_stain: Boolean!
  is_clear: Boolean!
  is_outsourced: Boolean!
  block_order_release: Boolean!
  archived: Boolean!
  attributeOptions: [AttributeOption!]!
  finishGroups: [FinishGroup!]!
}

input FinishOptionAttributeOptionRelation {
  sync: [ID!]
}

input FinishOptionFilter {
  ids: [ID]
  archived: Boolean
  name: String
  victor_name: String
  is_clear: Boolean
  is_prime: Boolean
  is_stain: Boolean
}

input FinishOptionFinishGroupRelation {
  connect: ID
  update: [UpdateFinishGroupInput!]
}

"""A paginated list of FinishOption items."""
type FinishOptionPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of FinishOption items."""
  data: [FinishOption!]!
}

input FixItInput {
  url: String!

  """Who is submitting this request?"""
  who: String!

  """What is the problem?"""
  what: String!

  """How should it work?"""
  how: String!

  """Base64 encoded string of screenshot / PNG contents."""
  screenshot: String
  context: JSON
}

input FlightProductionFilter {
  orderNumber: String!
  productTypeGroupIds: [String!]!
}

input ForgotPasswordInput {
  email: String!
}

type ForgotPasswordResponse {
  status: String!
  message: String
}

type FreightQuote {
  messages: [String!]!
  rateQuotes: [RateQuote!]!
}

input GetOrderFreightQuoteInput {
  orderNumber: String!
  options: ShipmentOptions
}

input GetRateQuoteInput {
  packages: [RateQuotePackage!]!
  destination: RateQuoteAddress!
  options: [ShippingProviderOption]!
}

input GetShipmentRateQuoteInput {
  shipmentId: ID!
  options: ShipmentOptions
}

enum GlassPanelType {
  NON_GLASS_PANEL
  GLASS_PANEL
  GLASS_PANEL_INCLUDE
}

type GlobalSale {
  id: ID!
  start_date: DateTime!
  end_date: DateTime!
  sale_percent: Float!
  productGroups: [ProductGroup]
  productTypes: [ProductType]
  productFamilies: [ProductFamily]
  products: [Product]
}

input GlobalSaleFilterInput {
  ids: [ID]
}

input GlobalSaleRelation {
  connect: [ID!]
  sync: [ID!]
  disconnect: [ID!]
}

enum HandrailType {
  NON_HANDRAIL
  HANDRAIL
  HANDRAIL_INCLUDE
}

type Inventory {
  product_id: ID!
  bin_qty: Int
  bin_count: Int
  inventory_type: InventoryType
  show_barcode: Boolean
  is_hpc: Boolean
  is_prepackaged: Boolean
  kanban_bin_location: String
  pick_to_light_device_id: String
  product: Product
}

enum InventoryType {
  None
  Vmi
  KanBan
}

enum IsValidToShipUserType {
  PRIVILEGED
  NONPRIVILEGED
  DEFAULT
}

type ItemException {
  id: ID!
  reason_id: ID!
  quantity: Int!
  order_line_item_id: ID!
  production_item_id: ID
  additional_notes: String
  created_by: ID!
  created_at: DateTime
  updated_at: DateTime
  closed: Boolean!
  closed_at: DateTime
  closed_by: ID
  createdBy: User!
  closedBy: User
  exceptionReason: ExceptionReason!
  order: Order!
  lineItem: OrderLineItem!
  productionItem: ProductionItem
}

enum ItemExceptionClosedFilter {
  CLOSED
  OPEN
  BOTH
}

input ItemExceptionFilterInput {
  ids: [ID!]
  date_from: DateTime
  date_to: DateTime
  reason_id: ID
  created_by: ID

  """The filter to apply for closed exceptions."""
  closed: ItemExceptionClosedFilter
  hasOd1ProductionTypes: [ProductionTypeEnum!]
  orderBy: [OrderByClause!]
}

input ItemExceptionUpdateRelation {
  create: [CreateItemExceptionInput!]
  update: [UpdateItemExceptionInput!]
  delete: [ID!]
}

"""
Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org.
"""
scalar JSON

type KanbanBin {
  id: ID!
  product_id: ID!
  quantity: Int!
  total_units: Int!
  refill_process_time: Int!
  point_of_use: String!
  bin_location: String!
  return_to: String!
  pick_to_light_device_id: ID
  active: Boolean!
  product: Product!
  pdfLink: String!
}

input KanbanBinCreateInput {
  product_id: ID!
  quantity: Int!
  total_units: Int!
  refill_process_time: Int!
  point_of_use: String!
  bin_location: String!
  return_to: String!
  pick_to_light_device_id: ID
  active: Boolean
}

input KanbanBinUpdateInput {
  id: ID!
  product_id: ID
  quantity: Int
  total_units: Int
  refill_process_time: Int
  point_of_use: String
  bin_location: String
  return_to: String
  pick_to_light_device_id: ID
  active: Boolean
}

input KanbanFilter {
  product_id: ID
  bin_location: String
  product_name: String
  point_of_use: String
}

type LeadTime {
  id: ID!
  name: String!
  days: Int!
}

type LineItemGraphQLResponse {
  lineItem: OrderLineItem
  warning: String
  success: Boolean!
}

input LineItemProductRelation {
  connect: ID
  create: CreateProductInput
  update: UpdateProductInput
  disconnect: Boolean
}

type Location {
  id: ID!
  name: String!
  qualified_chain: [String!]
  qualified_name: String!
  parent_id: ID
  parent: Location
  sublocations: [Location!]
  root_location: Location!
  packages: [Package!]
  pdfLink(type: String!): String!
}

type LocationAssignment {
  id: ID!
  location: Location
  locatable: Package!
  user: User
  moved_at: DateTime!
}

input LocationFilter {
  ids: [ID]
  name: String
  parent_id: ID
  orderBy: [OrderByClause!]
}

type LocationMarkup {
  id: ID!
  zip: ID!
  amount: Float!
  created_at: DateTime!
  updated_at: DateTime
}

"""A paginated list of Location items."""
type LocationPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Location items."""
  data: [Location!]!
}

enum LocationType {
  building
  truck
  bay
}

type Log {
  context: String
  level: String
  folder: String
  level_class: String
  level_img: String
  date: String
  text: String
  in_file: String
  stack: String
}

type LogIndex {
  log: [Log]
  folders: [String]
  current_folder: String
  folder_files: [String]
  files: [String]
  current_file: String
  structure: [String]
  storage_path: String
}

input LoginInput {
  username: String!
  password: String!
}

type LogoutResponse {
  status: String!
  message: String
}

type Manufacturing {
  product_id: ID!
  process_time: Int
  buffer_time: Int
  cnc_program: String
  production_data: JSON
  product: Product
}

type ManufacturingAttribute {
  id: ID!
  key: String
  datatype: String
  level: String
  products: [Product!]!
  options: [ManufacturingAttributeOption!]!
  deleted_at: DateTime
}

type ManufacturingAttributeOption {
  id: ID!
  value: String
  manufacturing_attribute_id: ID!
  manufacturingAttribute: ManufacturingAttribute!
  deleted_at: DateTime
}

input ManufacturingAttributeOptionRelation {
  create: [CreateManufacturingAttributeOption!]!
}

"""A paginated list of ManufacturingAttribute items."""
type ManufacturingAttributePaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of ManufacturingAttribute items."""
  data: [ManufacturingAttribute!]!
}

input ManufacturingAttributeSearchFilter {
  ids: [ID]
  key: String
}

type ManufacturingParameter {
  id: ID!
  voe_id: String!
  system_id: String!
  order_number: String!
  productionType: Od1ProductTypeProductionType
  production_type_id: ID
  manufacture_data: String!
}

input ManufacturingParameterCreateInput {
  voe_id: String!
  system_id: String!
  order_number: String!
  production_type_id: ID
  manufacture_data: String!
}

type ManufacturingParameterGraphQLResponse {
  warning: String
  success: Boolean!
}

input ManufacturingParameterSearch {
  ids: [ID!]
  voe_ids: [ID!]
  system_id: String
  order_number: String
  production_type_ids: [ID!]
}

input ManufacturingParameterUpdateInput {
  id: ID!
  voe_id: ID
  system_id: String
  order_number: String
  production_type_id: ID
  manufacture_data: String
}

input ManufacturingParametersBulkCreateInput {
  order_number: String!
  system_id: String!
  voe_ids: [VoeIdPayload!]!
}

type Material {
  id: ID!
  name: String!
  product_name: String!
  material_type: String!
  material_type_id: ID!
  finish_group_id: ID
  active: Boolean!
  finishGroup: FinishGroup
  MaterialSizes: [MaterialSize!]!
  MaterialType: MaterialType!
}

input MaterialFilter {
  ids: [ID!]
  name: String
  material_type_id: ID
  active: Boolean
}

type MaterialLength {
  id: ID!
  name: String!
  active: Boolean!
  material_type_id: ID!
  materialType: MaterialType
  unit_of_measure_id: ID!
  unitOfMeasure: UnitOfMeasure
  created_at: DateTime
  updated_at: DateTime
}

input MaterialLengthFilterInput {
  ids: [ID]
  name: String
  active: Boolean
  material_type_id: ID
}

type MaterialSize {
  id: ID!
  material_type_id: ID!
  MaterialType: MaterialType!
  name: String!
  type: String
  sort: Int!
  active: Boolean!
  created_at: DateTime!
  updated_at: DateTime
  Materials: [Material!]!
}

input MaterialSizeRelation {
  sync: [ID!]
}

input MaterialSizesInput {
  ids: [ID!]
  name: String
  material_type_id: ID
  active: Boolean
}

type MaterialType {
  id: ID!
  name: String!
  active: Boolean!
  materials(filter: MaterialFilter): [Material!]!
  created_at: DateTime!
  updated_at: DateTime!
}

enum MaterialTypes {
  wood
  metal
  glass
  plastic
  other
}

input MaterialTypesInput {
  ids: [ID!]
  name: String
  active: Boolean
}

input MergeShipmentIntoBatchInput {
  batch_id: ID!
  shipment_id: ID!
}

type MetaProductPivot {
  quantity: Int
}

input MetalBumpOutDashboardFilter {
  metalProductionDate: Date!
}

input MetalHandrailDashboardFilter {
  metalProductionDate: Date!
  material: MetalHandrailMaterial!
}

enum MetalHandrailMaterial {
  aluminum
  stainless
}

enum MetalHandrailStyle {
  handrail
  quick_slide
  beverage
  round_glasscap
  glasscap
  express
  base_rail_cover
  gen2_beverage_quick_slide
  gen2_quick_slide
  gen2_handrail
  round_grab
  round
}

enum MetalPostSkidSize {
  Small
  Medium
  Large
}

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

input ModifyFileGroupsInput {
  id: ID!
  groups: [FileGroupEnum!]
}

type ModifyShipmentBatchResponse {
  shipment: Shipment!
  batch: ShipmentBatch!
  success: Boolean!
  errors: [String!]!
  warnings: [String!]!
}

type Monitor {
  id: ID!
  job_id: String!
  name: String
  queue: String
  started_at: DateTime
  started_at_exact: DateTime
  finished_at: DateTime
  finished_at_exact: DateTime
  time_elapsed: Float
  status: Int!
  failed: Boolean!
  attempt: Int
  progress: Int
  exception: String
  exception_class: String
  exception_message: String
  data: JSON
}

"""A paginated list of Monitor items."""
type MonitorPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Monitor items."""
  data: [Monitor!]!
}

type Mutation {
  repoUpsertFromOrderNumber(input: RepoUpsertFromOrderNumber): Repo
  packMetalHandrail(input: PackMetalHandrailInput!): Order!
  createAddress(input: AddressCreateInput!): Address
  updateAddress(input: AddressUpdateInput!): Address
  copyAddressToContact(addressId: ID!, contactId: ID!): Boolean
  copyAddressToOrders(input: CopyAddressToOrdersInput!): Boolean
  updateApiKey(input: ApiKeyUpdateInput!): ApiKey
  createApiKey(input: ApiKeyCreateInput!): ApiKey
  deleteApiKey(id: ID!): ApiKey
  updateAppLog(input: AppLogUpdateInput!): AppLog
  updateAppSetting(input: UpdateAppSettingInput!): AppSetting
  setDefaultGroundShippingMethod(id: ID): ShippingMethodSetting
  setDefaultFreightShippingMethod(id: ID): ShippingMethodSetting
  setExpressRestockShippingMethod(id: ID): ShippingMethodSetting
  setDefaultDistributionCenter(id: ID): ShippingMethodSetting
  setWoodSampleProductTypes(ids: [ID]): WoodSampleProductTypesSetting
  createAttribute(input: CreateAttributeInput!): Attribute
  updateAttribute(input: UpdateAttributeInput!): Attribute
  deleteAttribute(id: ID!): Attribute
  createOption(input: CreateAttributeOptionInput!): AttributeOption
  updateOption(input: UpdateAttributeOptionInput!): AttributeOption
  deleteOption(id: ID!): AttributeOption
  createAudit(input: AuditCreateInput!): Audit
  updateAudit(input: AuditUpdateInput!): Audit
  deleteAudit(id: ID!): Audit
  createBuilding(input: CreateBuildingInput!): Building
  updateBuilding(input: UpdateBuildingInput!): Building
  deleteBuilding(id: ID!): Building
  createBundle(input: CreateBundleInput!): Bundle
  updateBundle(input: UpdateBundleInput!): Bundle
  createBundleGroup(input: CreateBundleGroupInput!): BundleGroup
  updateBundleGroup(input: UpdateBundleGroupInput!): BundleGroup
  deleteBundleGroup(id: ID!): BundleGroup
  createBundleRule(input: CreateBundleRuleInput!): BundleRule
  updateBundleRule(input: UpdateBundleRuleInput!): BundleRule
  deleteBundleRule(id: ID!): BundleRule
  createBundleRuleProduct(input: CreateBundleRuleProductInput!): BundleRuleProduct
  updateBundleRuleProduct(input: UpdateBundleRuleProductInput!): BundleRuleProduct
  updateCompany(input: CompanyUpdateInput!): Company
  createCompany(input: CompanyCreateInput!): Company
  deleteCompany(id: ID!): Company
  updateContact(input: ContactUpdateInput!): Contact
  createContact(input: ContactCreateInput!): Contact
  deleteContact(id: ID!): Contact
  createCostAccount(input: CreateCostAccountInput!): CostAccount
  updateCostAccount(input: UpdateCostAccountInput!): CostAccount
  deleteCostAccount(id: ID!): CostAccount
  createDeal(input: DealCreateInput): Deal
  updateDeal(input: DealUpdateInput!): Deal
  deleteDeal(id: ID!): Deal
  createDepartment(input: CreateDepartmentInput!): Department
  updateDepartment(input: UpdateDepartmentInput!): Department
  deleteDepartment(id: ID!): Department
  createDimension(input: CreateDimensionInput!): Dimension
  updateDimension(input: UpdateDimensionInput!): Dimension
  createEngineeringTask(input: EngineeringTaskCreateInput!): EngineeringTask
  updateEngineeringTask(input: EngineeringTaskUpdateInput!): EngineeringTask
  deleteEngineeringTask(id: ID!): EngineeringTask
  createEpc(input: EpcCreateInput!): Epc
  deleteEpcByCode(code: String!): Epc
  updateFile(input: FileUpdateInput!): File
  deleteFile(id: ID!): File
  deleteFiles(id: [ID!]!): [File!]!
  uploadFiles(input: FileUploadInput!): [File!]!
  addFileGroups(input: ModifyFileGroupsInput): File
  removeFileGroups(input: ModifyFileGroupsInput): File
  createFinishGroup(input: CreateFinishGroupInput!): FinishGroup
  updateFinishGroup(input: UpdateFinishGroupInput!): FinishGroup
  deleteFinishGroup(id: ID!): FinishGroup
  updateFinishGroupBulk(csv: String): Boolean
  createFinishOption(input: CreateFinishOptionInput!): FinishOption
  updateFinishOption(input: UpdateFinishOptionInput!): FinishOption
  deleteFinishOption(id: ID!): FinishOption
  updateFinishOptionBulk(csv: String!): Boolean
  createGlobalSale(input: CreateGlobalSaleInput!): GlobalSale
  updateGlobalSale(input: UpdateGlobalSaleInput!): GlobalSale
  deleteGlobalSale(id: ID!): GlobalSale
  createInventory(input: CreateInventoryInput!): Inventory
  updateInventory(input: UpdateInventoryInput!): Inventory

  """
  Mutation for opening an exception on a line-item level. Requires that this line item has no production items,
  otherwise will require the exception be opened at the prodcution item / bulk production item level.
  """
  openOrderLineItemException(reasonId: ID!, quantity: Int!, orderLineItemId: ID!, additionalNotes: String): ItemException

  """Mutation for opening an exception on a specific production item."""
  openProductionItemException(reasonId: ID!, productionItemId: ID!, additionalNotes: String): ItemException
  updateException(input: UpdateItemExceptionInput!): ItemException

  """Close an exception, using the ID of the exception that is open."""
  closeException(
    id: ID!

    """
    Whether we should reset all production steps for the associated production item.
    """
    resetProductionSteps: Boolean
  ): ItemException
  createKanbanBin(input: KanbanBinCreateInput!): KanbanBin
  updateKanbanBin(input: KanbanBinUpdateInput!): KanbanBin
  leadTimeCreate(input: leadTimeCreateInput!): LeadTime
  leadTimeUpdate(input: leadTimeUpdateInput!): LeadTime
  createLocation(input: CreateLocationInput!): Location
  updateLocation(input: UpdateLocationInput!): Location
  deleteLocation(id: ID!): Location
  clearAllPackagesFromLocation(id: ID!): Location
  createManufacturing(input: CreateManufacturingInput!): Manufacturing
  updateManufacturing(input: UpdateManufacturingInput!): Manufacturing
  upsertManufacturing(input: UpsertManufacturingInput!): Manufacturing
  createManufacturingAttribute(input: CreateManufacturingAttribute!): ManufacturingAttribute
  updateManufacturingAttribute(input: UpdateManufacturingAttribute!): ManufacturingAttribute
  deleteManufacturingAttribute(id: ID!): ManufacturingAttribute
  createManufacturingAttributeOption(input: CreateManufacturingAttributeOption!): ManufacturingAttributeOption
  updateManufacturingAttributeOption(input: UpdateManufacturingAttributeOption!): ManufacturingAttributeOption
  deleteManufacturingAttributeOption(id: ID!): ManufacturingAttributeOption
  createManufacturingParameter(input: ManufacturingParameterCreateInput!): ManufacturingParameter
  deleteManufacturingParameters(order_number: String!, system_id: String!): ManufacturingParameterGraphQLResponse
  bulkCreateManufacturingParameters(order_number: String!, system_id: String!, voe_ids: [VoeIdPayload!]!): ManufacturingParameterGraphQLResponse
  bulkDeleteByVoeId(voe_id: String!): ManufacturingParameterGraphQLResponse
  createMaterial(input: CreateMaterialInput!): Material!
  updateMaterial(input: UpdateMaterialInput!): Material!
  updateMaterialBulk(csv: String!): Boolean
  createMaterialLength(input: CreateMaterialLengthInput!): MaterialLength!
  updateMaterialLength(input: UpdateMaterialLengthInput!): MaterialLength!
  deleteMaterialLength(id: ID!): MaterialLength
  createMaterialSize(input: CreateMaterialSizeInput!): MaterialSize!
  updateMaterialSize(input: UpdateMaterialSizeInput!): MaterialSize!
  createMaterialType(input: CreateMaterialTypeInput!): MaterialType!
  updateMaterialType(input: UpdateMaterialTypeInput!): MaterialType!
  updateNote(input: UpdateNoteInput!): Note
  createNote(input: CreateNoteInput!): Note
  deleteNote(id: ID!): Note
  deleteNotes(ids: [ID!]!): [Note!]!
  od1ProductTypeCreate(input: Od1ProductTypeCreateInput!): OD1ProductType
  od1ProductTypeUpdate(input: Od1ProductTypeUpdateInput!): OD1ProductType
  od1ProductTypeDelete(id: ID!): OD1ProductType
  createOD1ProductTypeGroup(input: CreateOD1ProductTypeGroupInput!): OD1ProductTypeGroup
  updateOD1ProductTypeGroup(input: UpdateOD1ProductTypeGroupInput!): OD1ProductTypeGroup
  updateOrder(input: OrderUpdateInput!): Order
  updateOrders(inputs: [OrderUpdateInput!]!): [Order!]!
  updateOrderStatus(statusId: OrderStatusEnum!, orderId: ID!): Order
  undoOrderStatus(statusId: OrderStatusEnum!, orderId: ID!): Order
  toggleOrderFlag(flagId: OrderFlagEnum!, orderId: ID!): Order
  createOrder(input: OrderCreateInput!): Order
  deleteOrder(id: ID!): Order
  forceDeleteOrder(id: ID!): Order
  rebuildOrder(id: ID!): Order

  """
  Dispatches an order to the queue to be synced from OD1. Orders not existing in Terminal will be created and existing
  orders will be updated / refreshed and re-sync the line items / products.
  Returns true if an order was found and dispatched, or false if no matching order was found for the requested order
  number.
  """
  syncOrder(orderNumber: String!): SyncOrderResponse!
  reloadOrderItems(id: ID!): OrderGraphQLResponse
  refreshOrderProducts(id: ID!): Order
  splitOrder(input: SplitOrderInput!): Order

  """Updates the packing status of partially packed orders."""
  updatePartialItems(id: ID!): Order
  addPackageToShipment(orderId: ID!, packageId: ID!): Order
  removePackageFromShipment(orderId: ID!, packageId: ID!): Order
  od1SyncOrderAddress(id: ID!): Order

  """
  Requests an order to be placed in the small parts packing queue. Will set smallparts_packing_request_time and order
  to in_packing if not already set.
  """
  orderRequestSmallPartsPacking(id: ID!): Order! @deprecated(reason: "Replaced by 'orderRequestPacking'.")

  """
  Requests an order to be placed in the HPC packing queue. Will set hpc_request_time and order
  to in_packing if not already set.
  """
  orderRequestPacking(id: ID, order_number: String, package_id: ID, field: OrderRequestPackingField!, building_id: ID): Order!

  """
  Creates packages for each crate in production, and associates them with the individual pieces.
  """
  startCrateProduction(id: ID!): Order

  """
  Mutation for bulk completing production steps for all $lineItemIds on the order for the specified step. Will
  complete ALL open items for that step.
  """
  completeOrderProductionSteps(
    id: ID!

    """Line item IDs we should apply this to."""
    lineItemIds: [ID!]!

    """Production item step we should bulk mark complete."""
    step: ProductionItemStepColumn!

    """Used to notify a building a production step is set."""
    building_id: ID
  ): Order

  """
  Mutation for bulk completing production steps for $lineItemIds on the order for the specified step. Will only apply
  the completion event to up to requested $quantity, and will fail if attempting to mark more complete than available.
  """
  completeSomeOrderProductionSteps(
    id: ID!

    """Line item IDs we should apply this to."""
    lineItemIds: [ID!]!

    """Production item step we should bulk mark complete."""
    step: ProductionItemStepColumn!

    """
    Max quantity that we should mark complete. If empty, no limit will be applied (it will mark all it can), otherwise
    it will validate the quantity.
    """
    quantity: Int!

    """Used to notify a building a production step is set."""
    building_id: ID
  ): Order

  """
  Mutation for bulk uncompleting production steps for $lineItemIds on the order for the specified step. Will only apply
  the removal event to up to requested $quantity, and will fail if attempting to mark more uncomplete than available.
  """
  uncompleteSomeOrderProductionSteps(
    id: ID!

    """Line item IDs we should apply this to."""
    lineItemIds: [ID!]!

    """Production item step we should bulk mark uncomplete."""
    step: ProductionItemStepColumn!

    """
    Max quantity that we should mark uncomplete. If empty, no limit will be applied (it will mark all it can),
    otherwise it will validate the quantity.
    """
    quantity: Int!
  ): Order

  """Completes services by order_number."""
  completeServices(order_number: ID!, service_ids: [ID!]!): Order

  """
  Allows opening item exceptions in bulk on an order based on a few context / filtering criteria.
  """
  openOrderBulkItemExceptions(input: BulkOrderItemExceptionOpenInput!): Order

  """
  Allows closing item exceptions in bulk on an order based on a few context / filtering criteria.
  """
  closeOrderBulkItemExceptions(input: BulkOrderItemExceptionCloseInput!): Order

  """Checks and updates production engineering complete"""
  completeEngineering(id: ID!): Order

  """Adds instructions to an order."""
  addInstructions(orderId: ID!, files: [Upload!]!, tag: Tags!): Order
  syncOrderFiles(id: ID!): Order
  createOrderGroup(input: CreateOrderGroupInput!): OrderGroup
  updateOrderGroup(input: UpdateOrderGroupInput!): OrderGroup
  deleteOrderGroup(id: ID!): OrderGroup
  updateLineItem(input: OrderLineItemUpdateInput!): OrderLineItem
  createLineItem(input: OrderLineItemCreateInput!): OrderLineItem
  upsertLineItem(input: OrderLineItemUpsertInput!): OrderLineItem
  deleteLineItem(id: ID!): OrderLineItem

  """Complete a production step on a specific line item."""
  completeLineItemStep(input: OrderLineItemCompleteStepInput!): OrderLineItem

  """"Uncomplete" a production step on a specific line item."""
  uncompleteLineItemStep(input: OrderLineItemCompleteStepInput!): OrderLineItem

  """"Close" an exception on a specific line item."""
  closeItemException(id: ID!): OrderLineItem

  """"Removes" an exception on a specific line item."""
  removeItemException(id: ID!): OrderLineItem

  """"Update" an exception quantity on an existing exception."""
  updateItemException(id: ID!, quantity: Int!): OrderLineItem

  """Bulk update the notes field on one or more line items."""
  bulkUpdateLineItemNotes(ids: [ID!]!, notes: String): [OrderLineItem!]!
  syncSpecialItemToOd1(id: ID!): LineItemGraphQLResponse
  createOrderLineItemGroup(input: CreateOrderLineItemGroupInput!): OrderLineItemGroup
  updateOrderLineItemGroup(input: UpdateOrderLineItemGroupInput!): OrderLineItemGroup
  deleteOrderLineItemGroup(id: ID!): OrderLineItemGroup
  createOrderProductTypeGroupSchedule(input: CreateOrderProductTypeGroupScheduleInput!): OrderProductTypeGroupSchedule!
  updateOrderProductTypeGroupSchedule(input: UpdateOrderProductTypeGroupScheduleInput!): OrderProductTypeGroupSchedule!
  upsertOrderProductTypeGroupScheduleByFilter(input: UpdateOrderProductTypeGroupScheduleByFilterInput!): OrderProductTypeGroupSchedule!
  deleteOrderProductTypeGroupSchedules(filter: DeleteOrderProductTypeGroupScheduleFilter!): [OrderProductTypeGroupSchedule!]!
  applyOrderQuote(orderId: ID!, orderQuoteId: ID!): Order
  createOrderRemake(input: CreateOrderRemake!): OrderRemake
  updateOrderRemake(input: UpdateOrderRemake!): OrderRemake
  deletePackableItem(id: ID!): PackableItem
  createPackage(input: PackageCreateInput!): Package
  updatePackage(input: PackageUpdateInput!): Package
  deletePackage(id: ID!): Package
  addItemsToPackage(input: PackageItemInput!): Package
  removeItemsFromPackage(input: PackageItemInput!): Package
  packPackage(
    """ID of the package to pack."""
    id: ID!

    """ID of the package that we're packing _into_."""
    pack_into_id: ID!

    """
    The order that this package belongs to. Used to verify we're packing /
    unpacking packages that belong to the correct order.
    """
    order_id: ID
  ): Package
  unPackPackage(
    """ID of the package to pack."""
    id: ID!

    """
    The order that this package belongs to. Used to verify we're packing /
    unpacking packages that belong to the correct order.
    """
    order_id: ID
  ): Package
  updateBuildingId(
    """ID of the package to update."""
    package_id: ID

    """ID of the new building"""
    building_id: ID
  ): Package
  movePackageToLocation(package_id: ID, location_id: ID): Package
  createPackingBay(input: CreatePackingBayInput!): PackingBay
  updatePackingBay(input: UpdatePackingBayInput!): PackingBay
  deletePackingBay(id: ID!): PackingBay
  updatePermission(input: UpdatePermissionInput!): Permission
  createPiece(input: CreatePieceInput!): Piece
  updatePiece(input: UpdatePieceInput!): Piece
  createPiecePack(input: CreatePiecePackInput!): PiecePack
  updatePiecePack(input: UpdatePiecePackInput!): PiecePack
  createPostBracket(input: CreatePostBracketInput!): PostBracket!
  updatePostBracket(input: UpdatePostBracketInput!): PostBracket!
  deletePostBracket(id: ID!): PostBracket
  createPostTopStyle(input: CreatePostTopStyleInput!): PostTopStyle!
  updatePostTopStyle(input: UpdatePostTopStyleInput!): PostTopStyle!
  updatePostTopStyleBulk(csv: String!): Boolean
  deletePostTopStyle(id: ID!): PostTopStyle
  createPostTopType(input: CreatePostTopTypeInput!): PostTopType!
  updatePostTopType(input: UpdatePostTopTypeInput!): PostTopType!
  deletePostTopType(id: ID!): PostTopType
  createPricingTier(input: CreatePricingTierInput!): PricingTier
  updatePricingTier(input: UpdatePricingTierInput!): PricingTier
  deletePricingTier(id: ID!): PricingTier
  createProduct(input: CreateProductInput!): Product
  updateProduct(input: UpdateProductInput!): Product
  deleteProduct(id: ID!): Product
  createChildren(id: ID!): [Product!]!
  updatePostDimensionBulk(csv: String!): Boolean
  createProductCustomization(input: CreateProductCustomization!): ProductCustomization
  updateProductCustomization(input: UpdateProductCustomization!): ProductCustomization
  createProductFamily(input: CreateProductFamilyInput!): ProductFamily
  updateProductFamily(input: UpdateProductFamilyInput!): ProductFamily
  deleteProductFamily(id: ID!): ProductFamily
  createProductFeature(input: CreateProductFeature!): ProductFeature
  updateProductFeature(input: UpdateProductFeature!): ProductFeature
  createProductGroup(input: CreateProductGroupInput!): ProductGroup
  updateProductGroup(input: UpdateProductGroupInput!): ProductGroup
  deleteProductGroup(id: ID!): ProductGroup
  createProductType(input: CreateProductTypeInput!): ProductType
  updateProductType(input: UpdateProductTypeInput!): ProductType
  deleteProductType(id: ID!): ProductType
  completeProductionItemStep(input: ProductionItemCompleteStepInput!): ProductionItem
  uncompleteProductionItemStep(input: ProductionItemCompleteStepInput!): ProductionItem
  updateProductionItem(input: UpdateProductionItemInput!): ProductionItem

  """Requests creation of a small parts prep production job."""
  requestSmallPartsPrepProductionJob(order_number: String!, finish_option_id: ID!, job_label: String): ProductionJob
  completeProductionJob(id: ID!): ProductionJob
  uncompleteProductionJob(id: ID!): ProductionJob
  markProductionJobPartial(id: ID!): ProductionJob
  updateProductionSchedulingGroup(input: UpdateProductionSchedulingGroupInput!): ProductionSchedulingGroup
  createProductionSchedulingGroup(input: CreateProductionSchedulingGroupInput!): ProductionSchedulingGroup
  deleteProductionSchedulingGroup(id: ID!): ProductionSchedulingGroup
  createPurchaseOrder(input: CreatePurchaseOrderInput!): PurchaseOrder
  updatePurchaseOrder(input: UpdatePurchaseOrderInput!): PurchaseOrder
  deletePurchaseOrder(id: ID!): PurchaseOrder
  createPurchaseOrderLineItem(input: CreatePurchaseOrderLineItemInput!): PurchaseOrderLineItem
  updatePurchaseOrderLineItem(input: UpdatePurchaseOrderLineItemInput!): PurchaseOrderLineItem
  deletePurchaseOrderLineItem(id: ID!): PurchaseOrderLineItem
  createPurchasingPart(input: CreatePurchasingPartInput!): PurchasingPart
  updatePurchasingPart(input: UpdatePurchasingPartInput!): PurchasingPart
  deletePurchasingPart(id: ID!): PurchasingPart
  createPurchasingPartRequest(input: CreatePurchasingPartRequestInput!): PurchasingPartRequest
  createManyPurchasingPartRequest(input: [CreatePurchasingPartRequestInput!]): [PurchasingPartRequest!]!
  updatePurchasingPartRequest(input: UpdatePurchasingPartRequestInput!): PurchasingPartRequest
  updateManyPurchasingPartRequest(input: [UpdatePurchasingPartRequestInput!]): [PurchasingPartRequest!]!
  createRGARequest(input: CreateRGARequestInput!): RGARequest
  createRawMaterial(input: CreateRawMaterialInput!): RawMaterial
  updateRawMaterial(input: UpdateRawMaterialInput!): RawMaterial
  deleteRawMaterial(id: ID!): RawMaterial
  createReceivingLocation(input: CreateReceivingLocationInput!): ReceivingLocation
  updateReceivingLocation(input: UpdateReceivingLocationInput!): ReceivingLocation
  deleteReceivingLocation(id: ID!): ReceivingLocation
  createRole(input: CreateRoleInput!): Role
  updateRole(input: UpdateRoleInput!): Role
  deleteRole(id: ID!): Role
  updateRule(input: RuleUpdateInput!): Rule
  createRule(input: RuleCreateInput!): Rule
  deleteRule(id: ID!): Rule
  updateRuleTag(input: RuleTagUpdateInput!): RuleTag
  createRuleTag(input: RuleTagCreateInput!): RuleTag
  deleteRuleTag(id: ID!): RuleTag

  """Creates a completed_service with the service id and quantity."""
  completeService(id: ID!, quantity: Int!): Service
  createShipment(input: ShipmentCreateInput!): Shipment
  updateShipment(input: ShipmentUpdateInput!): Shipment
  deleteShipment(id: ID!): Shipment
  manuallyShipShipment(
    input: ShipmentUpdateInput!
    processorOptions: ShipmentProcessorOptions

    """Employee code of the supervisor to 'login' / bypass validation as."""
    supervisorEmployeeCode: String
  ): ShipmentResponse
  shipShipment(
    id: ID!
    options: ShipmentOptions
    method: ID
    processorOptions: ShipmentProcessorOptions

    """Employee code of the supervisor to 'login' / bypass validation as."""
    supervisorEmployeeCode: String

    """Base-64 encoded data URI to save / store as the customer's signature."""
    customerSignature: String
  ): ShipmentResponse
  voidShipment(id: ID!): Boolean
  dropshipItems(items: [DropshipItem!]!, shipmentInfo: ShipmentCreateInput!, processorOptions: ShipmentProcessorOptions): ShipmentResponse

  """Manually dispatch / send the notification of a Shipment to OD1."""
  sendShipmentToOd1(id: ID!, processorOptions: ShipmentProcessorOptions): Boolean!

  """
  Reset / unship a shipment, without sending all the voiding requests and deleting the shipment from the DB.
  """
  resetShipment(id: ID!): Shipment
  createShipmentBatch(input: CreateShipmentBatchInput!): ShipmentBatch
  deleteShipmentBatch(input: DeleteShipmentBatchInput!): ShipmentBatch
  upsertShipmentBatch(input: UpsertShipmentBatchInput!): ShipmentBatch
  updateShipmentBatch(input: UpdateShipmentBatchInput!): ShipmentBatch
  createShipmentBatchFromPackages(input: CreateShipmentBatchFromPackagesInput!): ShipmentBatch
  shipShipmentBatch(input: BulkShipInput!): ShipmentBatch
  addPackageToShipmentBatch(input: AddPackageToShipmentBatchInput!): ModifyShipmentBatchResponse
  removePackageFromShipmentBatch(input: RemovePackageFromShipmentBatchInput!): ModifyShipmentBatchResponse
  mergeShipmentIntoBatch(input: MergeShipmentIntoBatchInput!): ModifyShipmentBatchResponse
  generateShipmentBatchManifest(id: ID!): ShipmentBatch
  createShippingMethod(input: CreateShippingMethodInput!): ShippingMethod
  updateShippingMethod(input: UpdateShippingMethodInput!): ShippingMethod
  createSubAssembly(input: CreateSubAssemblyInput!): SubAssembly
  updateSubAssembly(input: UpdateSubAssemblyInput!): SubAssembly
  deleteSubAssembly(id: ID!): SubAssembly
  bulkDeleteSubAssemblies(input: SubAssemblyBulkDeleteFilter!): [SubAssembly!]!
  createSuggestedGroup(input: CreateSuggestedGroupInput!): SuggestedGroup
  updateSuggestedGroup(input: UpdateSuggestedGroupInput!): SuggestedGroup
  deleteSuggestedGroup(id: ID!): SuggestedGroup
  updateTag(input: UpdateTagInput!): Tag!
  tagFiles(input: TagFilesInput!): [File!]!
  untagFiles(input: TagFilesInput!): [File!]!
  createTransaction(input: TransactionCreateInput!): DealTransaction
  updateTransaction(input: TransactionUpdateInput!): DealTransaction
  deleteTransaction(id: ID!): DealTransaction
  createAndProcessTransaction(input: CreateAndProcessTransactionInput!): DealTransaction
  captureAuthorizedTransaction(id: ID!): DealTransaction
  cancelTransaction(id: ID!): DealTransaction
  createUnitOfMeasure(input: CreateUnitOfMeasureInput!): UnitOfMeasure!
  updateUnitOfMeasure(input: UpdateUnitOfMeasureInput!): UnitOfMeasure!
  deleteUnitOfMeasure(id: ID!): UnitOfMeasure
  createUser(input: CreateUserInput!): User
  updateUser(input: UpdateUserInput!): User
  deleteUser(id: ID!): User
  restoreUser(id: ID!): User
  createVendor(input: CreateVendorInput!): Vendor
  updateVendor(input: UpdateVendorInput!): Vendor
  deleteVendor(id: ID!): Vendor
  createVendorPart(input: CreateVendorPartInput!): VendorPart
  updateVendorPart(input: UpdateVendorPartInput!): VendorPart
  deleteVendorPart(id: ID!): VendorPart
  updateVrdDelivery(input: VrdDeliveryInput!): VrdDelivery!
  updateVrdDeliveryBulk(csv: String!): Boolean
  requestRGAEmail(
    """Email address associated with the customer's order."""
    email: String!

    """
    Any zip code associated with this customer (either order billing or shipping, or the zip code on the customer
    contact).
    """
    zipCode: String!
  ): Boolean
  customerCreateAndProcessTransaction(input: CustomerCreateAndProcessTransactionInput!): DealTransaction
  completeWoodSampleSteps(production_item_ids: [ID!]!): CompleteWoodSampleSteps!
  completeWoodSteps(production_item_ids: [ID!]!, steps: [ProductionItemStepColumn!]!): CompleteWoodSteps!
  fixIt(input: FixItInput!): Boolean
  login(input: LoginInput!): AuthPayload!
  refreshToken(input: RefreshTokenInput): RefreshTokenPayload!
  logout: LogoutResponse!
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordResponse!
  updateForgottenPassword(input: NewPasswordWithCodeInput): ForgotPasswordResponse!
  register(input: RegisterInput): RegisterResponse!
  socialLogin(input: SocialLoginInput!): AuthPayload!
  verifyEmail(input: VerifyEmailInput!): AuthPayload!
}

input NewPasswordWithCodeInput {
  email: String!
  token: String!
  password: String!
  password_confirmation: String!
}

type Notable {
  id: ID!
  relatedRecordId: ID!
  RelationType: RelationType!
  notes: [Note!]!
}

union NotableTreeModels = Deal | Order | OrderLineItem

type NotableTreeNode {
  id: ID!
  label: String!
  relationType: RelationType!
  notable: Notable
  model: NotableTreeModels!
  children: [NotableTreeNode!]
}

type Note {
  id: ID!
  content: String!
  user_id: ID
  user: User
  tags: [Tag!]!
  created_at: DateTime
  updated_at: DateTime
  audits: [Audit!]!
}

input NoteDealsRelation {
  connect: [ID!]!
}

input NoteFilterInput {
  ids: [ID]
}

input NoteLineItemsRelation {
  connect: [ID!]!
}

input NoteOrdersRelation {
  connect: [ID!]!
}

input NoteTagRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
}

type OD1Company {
  id: ID!
  name: String
  address: String
  city: String
  state: String
  zip: String
  country: String
  phone_number: String
  fax_number: String
}

type OD1File {
  id: ID!
  FileID: Int!
  orderID: Int!
  orderCustomerVisibleID: Int!
  orderEngineeringID: Int!
  orderPackagingID: Int!
  productID: Int!
  diagramProductID: Int!
  purchasingProductID: Int!
  purchaseOrderID: Int!
  orderItemsID: Int!
  orderShipmentID: Int!
  inHouseOrderShipmentID: Int!
  customerID: Int!
  rgaRequestStatusID: Int!
  FileName: String!
  FileTitle: String!
  TitleProcessed: Boolean!
  ThumbnailFileName: String!
  ThumbnailWidth: Int!
  ThumbnailHeight: Int!
  RecordCreated: DateTime!
  RecordUpdated: DateTime!
  url: String!
  thumbnailUrl: String!
  extension: String!
}

enum OD1FileType {
  ORDER
  ENGINEERING
  PACKAGING
  CUSTOMER
  DIAGRAM
  PACKING
}

type OD1ProductType {
  id: ID!
  od1_product_type_group_id: ID
  additional_od1_product_type_group_id: ID
  redistribute_account_id: ID
  post_top_style_id: ID
  od1_product_type_production_type_id: ProductionTypeEnum
  od1_product_type_accounting_type_id: ID
  post_mounting_style_id: ID
  post_system_type_id: ID
  handrail_type_id: HandrailType
  glass_panel_type_id: GlassPanelType
  rod_type_id: RodType
  stringer_type_id: StringerType
  name: String!
  redistribute_amount: Float
  warn_on_unset_prc_or_final: Boolean!
  special_order_prefix: String
  show_on_inventory: Boolean!
  show_on_add_order_item: Boolean!
  special: Boolean!
  requires_approval: Boolean!
  can_edit_list_price: Boolean!
  can_edit_cost_general: Boolean!
  can_have_discount: Boolean!
  fixture_numbers_empty_when_autosuggested: Boolean!
  requires_engineering: Boolean!
  can_be_extra: Boolean!
  non_physical_products: Boolean!
  lead_days: Int!
  dropship: Boolean!
  virtual: Boolean!
  returnable: Boolean!
  post_type: PostType!
  group: OD1ProductTypeGroup
  products: [Product]
  additionalGroup: OD1ProductTypeGroup
  redistributeAccount: Od1ProductTypeAccountingType
  postTopStyle: PostTopStyle
  productionType: Od1ProductTypeProductionType
  accountingType: Od1ProductTypeAccountingType
  capacity: Int!
  postSystemType: PostSystemType
  postMountingStyle: PostMountingStyle
  productCustomizations: [ProductCustomization]
  productFeatures: [ProductFeature!]!
}

input OD1ProductTypeFilter {
  od1_product_type_group_id: ID
  od1_accounting_type_ids: [ID!]
}

type OD1ProductTypeGroup {
  id: ID!
  name: String!
  parent_group_id: ID @deprecated(reason: "Field does not exist in DB.")
  od1_parent_group_id: ID
  active: Boolean!
  parent: OD1ProductTypeGroup
  od1ProductTypes: [OD1ProductType!]!
  od1ProductionTypes: [Od1ProductTypeProductionType!]!
  children: [OD1ProductTypeGroup!]!
  types: [OD1ProductType!]!
}

input OD1ProductTypeGroupFilter {
  ids: [ID!]
  od1_parent_group_id: ID
  od1_parent_group_ids: [ID!]
  active: Boolean
}

type OD1SalesFile {
  id: ID!
  SalesFileID: ID!
  groupID: ID!
  FileHeadline: String!
  FileDescription: String!
  file_name: String!
  thumbnail: String!
  thumbnail_width: Int!
  thumbnail_height: Int!
  archived: Boolean!
  RecordCreated: DateTime!
  RecordUpdated: DateTime!
  url: String!
  thumbnailUrl: String!
  extension: String!
  group: OD1SalesGroupEnum!
}

enum OD1SalesGroupEnum {
  COMPLETED_PROJECTS
  INSTALLATION_INSTRUCTIONS
}

type Od1ProductTypeAccountingType {
  id: ID!
  title: String!
  sort_order: Int!
}

input Od1ProductTypeCreateInput {
  od1_product_type_group_id: ID
  additional_od1_product_type_group_id: ID
  redistribute_account_id: ID
  post_top_style_id: ID
  od1_product_type_production_type_id: ProductionTypeEnum
  od1_product_type_accounting_type_id: ID
  post_mounting_style_id: ID
  post_system_type_id: ID
  handrail_type_id: HandrailType
  glass_panel_type_id: GlassPanelType
  rod_type_id: RodType
  stringer_type_id: StringerType
  name: String
  redistribute_amount: Float
  warn_on_unset_prc_or_final: Boolean
  special_order_prefix: String
  show_on_inventory: Boolean
  show_on_add_order_item: Boolean
  special: Boolean
  requires_approval: Boolean
  can_edit_list_price: Boolean
  can_edit_cost_general: Boolean
  can_have_discount: Boolean
  fixture_numbers_empty_when_autosuggested: Boolean
  requires_engineering: Boolean
  can_be_extra: Boolean
  non_physical_products: Boolean
  lead_days: Int
  dropship: Boolean
  virtual: Boolean
  returnable: Boolean
  post_type: PostType
  productCustomizations: Od1ProductTypeProductCustomizationRelation
  productFeatures: Od1ProductTypeProductFeatureRelation
}

enum Od1ProductTypeGroups {
  THREE_EIGHTS
  ONE_HALF
  SHIPPING_CRATE
  NINE_SIXTEENTHS
  ONE_QUARTER
  LAMINATED_PANEL
  SAMPLE_BOXES
  PRODUCTION_SAMPLES
}

input Od1ProductTypeInput {
  ids: [ID]
  name: String
  lead_days: Int
}

input Od1ProductTypeProductCustomizationRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  create: CreateProductCustomization
  update: UpdateProductCustomization
}

input Od1ProductTypeProductFeatureRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  create: CreateProductFeature
  update: UpdateProductFeature
}

type Od1ProductTypeProductionType {
  id: ProductionTypeEnum!
  name: String!
  internal_name: String!
  od1ProductTypeGroups: [OD1ProductTypeGroup!]!
  od1ProductTypeGroupIds: [ID!]!
  productionSchedulingGroups: [ProductionSchedulingGroup!]!
  types: [OD1ProductType!]!
}

input Od1ProductTypeUpdateInput {
  id: ID!
  lead_days: Int
  od1_product_type_group_id: ID
  additional_od1_product_type_group_id: ID
  redistribute_account_id: ID
  post_top_style_id: ID
  od1_product_type_production_type_id: ProductionTypeEnum
  od1_product_type_accounting_type_id: ID
  post_mounting_style_id: ID
  post_system_type_id: ID
  handrail_type_id: HandrailType
  glass_panel_type_id: GlassPanelType
  rod_type_id: RodType
  stringer_type_id: StringerType
  name: String
  redistribute_amount: Float
  warn_on_unset_prc_or_final: Boolean
  special_order_prefix: String
  show_on_inventory: Boolean
  show_on_add_order_item: Boolean
  special: Boolean
  requires_approval: Boolean
  can_edit_list_price: Boolean
  can_edit_cost_general: Boolean
  can_have_discount: Boolean
  fixture_numbers_empty_when_autosuggested: Boolean
  requires_engineering: Boolean
  can_be_extra: Boolean
  non_physical_products: Boolean
  dropship: Boolean
  virtual: Boolean
  returnable: Boolean
  post_type: PostType
  productCustomizations: Od1ProductTypeProductCustomizationRelation
  productFeatures: Od1ProductTypeProductFeatureRelation
}

enum Od1ProductTypes {
  WOOD_FINISH
  GLASS_TALON
}

type Order {
  id: ID!
  order_group_id: ID
  deal_id: ID!
  customer_service_employee_id: ID
  project_manager_employee_id: ID
  sales_support_employee_id: ID
  order_number: String!
  od1_company_id: String!
  od1Company: OD1Company!
  order_type_id: OrderType!
  current_status: OrderStatusEnum
  progress: Int!
  total: Float!
  total_assigned: Float!
  item_tax: Float
  shipping_tax: Float
  estimated_shipping_cost: Float
  actual_shipping_cost: Float
  liftgate_delivery_charge: Float
  shipping_charge: Float
  shipping_method_id: ID
  payment_method_id: ID
  payment_term_id: ID
  user_id: ID
  od1_sales_team_id: ID
  billing_address_id: ID
  shipping_address_id: ID
  final_shipping_address_id: ID
  shipping_notes: String
  priority_production_notes: String
  secondary_production_notes: String
  shipping_directions: String
  production_engineering_required: Boolean!
  production_engineering_required_wood: Boolean!
  production_engineering_required_glass: Boolean!
  production_engineering_required_fabrication: Boolean!
  production_engineering_complete: Boolean!
  production_engineering_complete_wood: Boolean!
  production_engineering_complete_glass: Boolean!
  production_engineering_complete_fabrication: Boolean!
  expected_ship_date: Date
  ship_after_date: Date
  due_date: Date
  delivery_window_from: Date
  delivery_window_to: Date
  metal_final_date: Date
  glass_final_date: Date
  flight_final_date: Date
  wood_final_date: Date
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
  hpc_request_time: DateTime
  smallparts_prep_request_time: DateTime
  smallparts_packing_request_time: DateTime
  tax_contact_id: ID
  job_name: String

  """
  The restocking fee (in percent - 25 = 25%) applied to this individual order.
  """
  restocking_fee_percent: Int!
  extended_return_window: Boolean!
  sales_employee_id: ID
  is_remake: Boolean!
  remake_notes: String
  remake_of_order_id: ID
  building_id: ID
  created_at: DateTime
  updated_at: DateTime
  lineItemTotal: Float!
  lineItemDiscountTotal: Float!
  itemCount: Int

  """Gets the date the order [fully] shipped / the last shipment."""
  shipDate: Date
  orderedDate: DateTime
  releasedDate: DateTime
  releasable: Boolean!
  releaseableToShipping: Boolean!
  releaseableToShipped: Boolean!
  canChangeStatusTo(status: OrderStatusEnum!): Boolean
  canChangeStatusToMessages(status: OrderStatusEnum!): [String!]!

  """Whether this order has passed validation to schedule to production."""
  canScheduleForProduction: Boolean!
  calculateBalanceForStatus(status: OrderStatusEnum!): Float!
  calculateBalanceForNextStep: Float!

  """
  Gets the date / timestamp for the first result for a given status filter.
  """
  statusDate(filter: OrderStatusFilter): DateTime
  latestStatus: OrderStatus
  accountingBreakdown: JSON!

  """
  Generates JSON breakdown of production Groups and Types, and their associated totals.
  """
  productionBreakdown: JSON!
  hasProductGroup(groupType: ID!): Boolean!
  hasProductTypeProductionType(type: ProductionTypeEnum!): Boolean!
  hasExpressItems: Boolean!
  hasLargeExpressItems: Boolean!
  hasLargeStockItems: Boolean!
  packableItemsCount: Int!

  """Determines the percentage of items that are inside a shipment."""
  percentageOfItemsInShipment: Float!
  allItemsPacked: Boolean!

  """Checks to see if packable items have been packed into packages."""
  isPackingInProgress(
    """
    Scope that exists on PackableItem that we should apply to filter the results of this query.
    """
    scope: String
  ): Boolean!

  """
  Checks an order via OD1 to see if all line items on the order are stock only.
  """
  isStockOnly: Boolean!

  """
  Checks an order via OD1 to see if all NON-SHIPPED line items on the order are stock only.
  """
  isRemainingStockOnly: Boolean!

  """Queries OD1 to see if any line items on the order are samples."""
  hasSamples: Boolean!

  """
  Checks to see whether or not this order has items marked as 'ship_as_freight'.
  """
  hasFreightItems: Boolean!

  """
  Checks to see that the order follows our rules for "Same day shipping."
  """
  isSameDayShipping: Boolean!

  """
  Queries against OD1 to determine that all products related to line items are in stock.
  """
  isAllItemsInStock: Boolean!

  """Checks to see if an order is, or was at one point, partial"""
  isOrWasPartial: Boolean!

  """
  Checks to see if an order is needs / is flagged for Liftgate on delivery.
  """
  needsLiftgate: Boolean!

  """
  Checks to see if order has multiple production types or can be shipped independently
  """
  isIndependent: Boolean!

  """
  Returns the production types associated with the (non virtual, or dropship) line items on this order.
  """
  productionTypes: [Od1ProductTypeProductionType!]!

  """Returns the signed URL for creating a new RGA request."""
  rgaReturnLink: String!
  getURL(type: OrderURLType!, absolute: Boolean = false): String!
  returnItems: [ReturnItem!]!

  """
  Checks if this order has one or more of the product type IDs supplied.
  """
  hasOd1ProductTypes(ids: [ID!]!): Boolean

  """Checks an order to see if all HPC items on the order are packed."""
  isHpcPacked: Boolean!

  """Checks an order to see if all stock items on the order are packed."""
  isStockPacked: Boolean!

  """Checks an order to see if all packages are available to ship"""
  isAllPackagesAvailableToShip: Boolean!
  isNextDayAir: Boolean!

  """
  Performs order-level validation to determine if the order is ready for shipping.
  """
  isValidToShip(
    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): Boolean

  """Returns an array of strings / validation errors if not valid."""
  isValidToShipMessages(
    """Whether or not we should bail on the first found error."""
    bailEarly: Boolean = false

    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): [ValidationMessage!]!

  """
  Perform a few pieces of validation to see if we are able to act on this order
  (through packing, production, shipping, etc).
  """
  canActOnOrder: Boolean!

  """
  Perform a few pieces of validation to see if we are able to act on this order
  (through packing, production, shipping, etc) and return the error messages /
  """
  canActOnOrderMessages: [ValidationMessage!]!
  hasFiles: Boolean!
  od1Files(type: OD1FileType): [OD1File!]!
  od1SalesFiles(type: OD1FileType): [OD1SalesFile!]!
  isPaid: Boolean!

  """Checks to see if order being sent to Ship is packed and partial"""
  isPackedAndPartial: Boolean!

  """
  Returns an array of [PackableItemType => IsPacked] for each type on an order.
  Used to determine the packed status for every type on an order.
  """
  packedStatusByType: JSON!

  """
  Returns the calculated order totals / price breakdown from OD1 for this order.
  """
  totals: OrderPriceTotals!
  pdfLink(type: OrderPdfTypes!, prodType: ProductionTypeEnum, material: MetalHandrailMaterial, ids: [ID!]): String!

  """Return the print server installation binder information."""
  printServerBinder: PrintServerPrintRequest!

  """
  Gets the suggested skid size for packing posts based on the volume algorithm for packing posts on an order.
  """
  postSkidSizeRecommendation: MetalPostSkidSize!

  """Returns an array of finish option names."""
  finishOptionNames: [String!]!
  postMaterialNames: [String!]!
  notable: Notable!
  fileable: Fileable!
  filesToPrint: [File!]
  group: OrderGroup
  billingAddress: Address
  groups: [OrderLineItemGroup!]!
  deal: Deal!
  items(filter: OrderLineItemFilterInput, query: OrderLineItemQueryInput): [OrderLineItem!]!
  shippingAddress: Address
  finalShippingAddress: Address
  addresses: [Address!]!
  files: [File!]!
  customerFiles: [File!]!
  user: User
  salesEmployee: User
  customerServiceEmployee: User
  projectManagerEmployee: User
  salesSupportEmployee: User
  shippingMethod: ShippingMethod
  owner: User
  taxContact: Contact
  quotes: [OrderQuote!]!
  statuses(filter: OrderStatusFilter): [OrderStatus!]!
  flags: [OrderFlag!]!
  packages(filter: PackageFilter): [Package!]!
  allPackages(filter: PackageFilter): [Package!]!
  shipments(filter: ShipmentFilter): [Shipment!]!
  audits: [Audit!]!
  notes: [Note!]!
  allAudits: [Audit!]!

  """
  Checks whether the order has an open exception on one of the line items.
  """
  hasOpenException(
    """The exception reasons we should filter by."""
    exceptionReasonIds: [ID!]

    """Specific line item IDs to filter by / check against."""
    lineItemIdsToCheck: [ID!]
  ): Boolean
  exceptions: [ItemException!]!
  engineeringTasks: [EngineeringTask!]!
  status: OrderStatus

  """Returns all product groups that exist on line items on this order."""
  productGroups: [ProductGroup!]!
  orderProductTypeGroupSchedules: [OrderProductTypeGroupSchedule!]!
  packableItems(filter: PackableItemFilter): [PackableItem!]!

  """
  Relation to pull all products associated with this order, using line items as the through model.
  """
  products: [Product!]
  productionItems(filter: ProductionItemFilterInput, query: ProductionItemQueryInput): [ProductionItem!]!
  productionItemSteps: [ProductionItemStep!]!

  """Packable items filtered by HPC scope."""
  packableItemsHpc: [PackableItem!]!
  od1ProductTypes: [OD1ProductType!]!
  od1ProductTypeGroups: [OD1ProductTypeGroup!]!

  """Gets the related services."""
  services: [Service!]!
  paymentMethod: PaymentMethod
  salesTeam: SalesTeam
  building: Building
  canCompleteEngineering: Boolean
  itemGroups: [OrderLineItemGroup!]!
  remakeOfOrder: Order
  remakeOrders: [Order!]!

  """Returns the shipping notes from OD1."""
  od1ShippingNotes: String @deprecated(reason: "Use shipping_notes property on order instead.")
  suggestedShipDate: Date @deprecated(reason: "Not developed.")
}

input OrderAddressRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  create: [AddressCreateInput!]
  update: [AddressUpdateInput!]
}

"""Allows ordering a list of records."""
input OrderByClause {
  """The column that is used for ordering."""
  column: String!

  """The direction that is used for ordering."""
  order: SortOrder!
}

enum OrderByRelationAggregateFunction {
  COUNT
}

enum OrderByRelationWithColumnAggregateFunction {
  AVG
  MIN
  MAX
  SUM
  COUNT
}

input OrderCreateInput {
  deal_id: ID!
  order_number: String
  order_type_id: OrderType
  od1_company_id: String
  current_status: OrderStatusEnum
  billing_address_id: ID
  shipping_address_id: ID
  final_shipping_address_id: ID
  user_id: ID
  created_at: DateTime
  updated_at: DateTime
  shipping_method_id: ID
  remake_of_order_id: ID
  estimated_shipping_cost: Float
  actual_shipping_cost: Float
  shipping_charge: Float
  shipping_notes: String
  shipping_directions: String
  payment_term_id: ID
  payment_method_id: ID
  tax_contact_id: ID
  expected_ship_date: Date
  due_date: Date
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
  hpc_request_time: DateTime
  smallparts_packing_request_time: DateTime
  smallparts_prep_request_time: DateTime
  addresses: OrderAddressRelation
  shipments: OrderShipmentRelation
  packages: OrderPackageRelation
}

input OrderFilterInput {
  ids: [ID]
  order_number: String
  active: Boolean
  statusIds: [ID!]
  flagIds: [ID!]
  contact_ids: [ID!]
  orderBy: [OrderByClause!]
  current_status: [OrderStatusEnum!]
  date_from: Date
  date_to: Date
  has_hpc_request_time: Boolean
  has_smallparts_packing_request_time: Boolean
  has_smallparts_prep_request_time: Boolean
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
  order_product_type_group_schedule_production_date: OrderProductTypeGroupScheduleScopeFilter
  has_od1_production_type: [ID!]
  has_od1_product_type: [ID!]
  has_od1_product_type_group: [ID!]

  """
  Performs a where check to see if ANY production dates are scheduled for the passed date.
  """
  production_date: Date
  include_on_hold: Boolean
  in_packing: Boolean
  has_hpc: Boolean
  has_small_parts: Boolean
  has_small_parts_packing: Boolean
  has_hpc_packing: Boolean
  order_type_id: [OrderType!]
  package_ids: [ID!]
  handrailPackingIndex: Boolean
  remake_of_order_id: ID
}

type OrderFlag {
  id: ID
  order_id: ID!
  order_flag_id: ID!
  flag: OrderFlagEnum!
  created_at: DateTime!
  updated_at: DateTime!
  resolved_at: DateTime
  user_id: ID
  user: User!
}

enum OrderFlagEnum {
  SCRUBBED
  ON_HOLD
  EXCEPTION
  PARTIAL
}

type OrderGraphQLResponse {
  order: Order
  errors: [String!]!
  warnings: [String!]!
  success: Boolean!
}

type OrderGroup {
  id: ID!
  hubspot_deal_id: ID!
  name: String!
  sort: Int
  orders: [Order!]!
}

input OrderGroupRelation {
  create: [CreateOrderGroupInput!]
  update: [UpdateOrderGroupInput!]
  delete: [ID!]
}

type OrderItemsReport {
  order_line_items_id: ID!
  order_line_items_name: String!
  order_line_items_quantity: Int
  production_item_steps_quantity: Int!
  materials_name: String
  finish_options_name: String
  production_items_piece_number: String
  exceptions: WoodExceptions!
}

type OrderLineItem {
  id: ID!
  order_line_item_group_id: ID
  name: String!
  description: String
  item_notes: String
  customer_notes: String
  post_numbers_list: String
  handrail_numbers_list: String
  glass_panel_numbers_list: String
  rod_numbers_list: String
  stringers_numbers_list: String
  order_id: ID!
  quantity: Int!
  shipped_quantity: Int!
  product_id: ID
  group_sort: Int
  price: Float!
  percent_discount: Float
  finish_price: Float
  finish_option_id: ID
  post_angle: Float
  expiration_date: DateTime
  fallback_percent_discount: Float
  parent_line_item_id: ID
  is_custom: Boolean!
  special: Boolean!
  sent_quantity: Int
  created_at: DateTime!
  updated_at: DateTime
  total: Float!
  group_id: ID
  has_numbers_list: Boolean!
  order: Order!
  fileable: Fileable!
  finishOption: FinishOption
  children: [OrderLineItem!]!
  itemGroup: OrderLineItemGroup
  productGroup: ProductGroup
  productType: ProductType
  productFamily: ProductFamily
  od1ProductType: OD1ProductType
  od1ProductGroup: OD1ProductTypeGroup
  od1ProductionType: Od1ProductTypeProductionType
  material: Material
  materialSize: MaterialSize
  postTopStyle: PostTopStyle
  postFootStyle: PostFootStyle
  product: Product
  productInventory: Inventory
  kanbanBins: [KanbanBin!]!
  packages: [Package!]!
  files: [File!]!
  audits: [Audit!]!
  notes: [Note!]!

  """
  Finds the shipments that this line item is on by searching through the packable pieces, and packages associated with
  those items.
  """
  shipments: [Shipment!]!

  """
  Returns the shipped date (latest date for a shipment this line item is on) if the item is fully shipped.
  """
  shipped_date: DateTime

  """
  Returns all exceptions on the line item, including production-item level exceptions.
  """
  exceptions(filter: ItemExceptionFilterInput): [ItemException!]!
  exception: ItemException

  """
  Returns the relation to the product feature(s). This does not account for changes in pricing, naming, that could
  happen over time. See OrderLineItem::featurePivots for that.
  """
  features: [ProductFeature!]!

  """
  Return the product feature pivot table as a model, so we can access pricing / per item name information. This
  provides us with the 'correct' model for line item specific features.
  """
  featurePivots: [OrderLineItemProductFeature!]!
  productionItems(filter: ProductionItemFilterInput): [ProductionItem!]!
  productionItemSteps: [ProductionItemStep!]!
  pieces(filter: PieceFilter): [Piece!]!
  subAssemblies: [SubAssembly!]!

  """
  Dynamically returns the appropriate numbers list based on the line item's production type.
  Includes: post, handrail, glass panel, rod, and stringer numbers lists.
  """
  numbersList: String

  """
  Returns an array of links to view PDFs / files related to production (based on
  the specific cell provided) for this line item.
  """
  productionCellFiles(cell: OrderLineItemProdCellFileType): [String!]!
  sale_price_percent: Float
  globalSale: GlobalSale

  """Queries, and caches, files from OD1."""
  od1Files(type: OrderLineItemOD1FileType): [OD1File!]!

  """
  Returns the count of OD1 files present for this item & type requested.
  """
  od1FilesCount(type: OrderLineItemOD1FileType): Int!

  """Returns the [open] exception bound to this individual line item."""
  hasOpenException: Boolean!
  exceptionQuantity: Int!

  """Total discount in $ for a single quantity of this item."""
  discount: Float!

  """
  Final price including addons, discounts, for a single quantity of this line item.
  """
  finalPrice: Float!

  """Gets meta for the current item."""
  meta: [OrderLineItemMeta!]!
  packedQuantity: Int!
  isHpc: Boolean!

  """
  Checks to see whether this item would fall into angled metal post production or not.
  """
  isAngledMetalProduction: Boolean!

  """Checks whether or not this line item has production items."""
  hasProductionItems: Boolean!

  """
  Returns the number of production items for this order that have the requested step completed.
  """
  productionStepCompleteCount(
    """The column we should be counting complete steps for."""
    column: ProductionItemStepColumn!
  ): Int!

  """
  Returns a summary for all the production steps on this line item, their completed quantities, and the completion
  date (if applicable / if all items are complete).
  """
  productionStepSummary: OrderLineItemProductionStepSummary!

  """Returns the date of the earliest step for $column marked complete."""
  productionStartDate(column: ProductionItemStepColumn!): Date

  """
  Returns the date of the last step for $column marked complete - only if ALL of this item are complete.
  """
  productionEndDate(column: ProductionItemStepColumn!): Date
  handrail_style: MetalHandrailStyle
  manufactureData: String
  pdfLink(type: OrderLineItemPdfType!): String
  voeNumber: String
}

input OrderLineItemChildrenRelation {
  create: [OrderLineItemCreateInput]!
}

input OrderLineItemCompleteStepInput {
  id: ID!
  step: ProductionItemStepColumn!
  quantity: Int = 1
}

input OrderLineItemCreateInput {
  name: String
  order_id: ID!
  price: Float
  finish_price: Float
  quantity: Int!
  description: String
  item_notes: String
  customer_notes: String
  post_numbers_list: String
  percent_discount: Float
  expiration_date: DateTime
  fallback_percent_discount: Float
  finish_option_id: ID
  parent_line_item_id: ID
  is_custom: Boolean
  order_line_item_group_id: ID
  group_sort: Int
  product_id: ID
  exceptions: ItemExceptionUpdateRelation
  children: OrderLineItemChildrenRelation
  features: ProductFeatureRelation
  group: OrderLineItemGroupItemsRelation
}

input OrderLineItemFilterInput {
  ids: [ID!]
  has_product_ids: [ID!]
  has_finish_option_ids: [ID!]
  has_od1_product_types: [ID!]
  has_od1_product_type_groups: [ID!]
  has_od1_production_types: [ProductionTypeEnum!]
  postTypes: [PostType!]

  """
  Supply a list of material IDs that we should filter the results to include.
  """
  hasMaterials: [ID!]
  hasProductionDateBetween: [Date]

  """
  Filter items by bin locations matching the requested string.
  Passing any 'like' strings to filter by. Ex: "1W-PC%" would filter items by
  those with bin locations starting with "1W-PC".
  """
  has_kanban_bin_locations_like: String
  not_in_group: Boolean
  keywords: String
}

type OrderLineItemGroup {
  id: ID!
  name: String!
  sort: Int
  created_at: DateTime!
  updated_at: DateTime!
  items: [OrderLineItem!]!
}

input OrderLineItemGroupItemsRelation {
  create: [OrderLineItemCreateInput!]
  update: [OrderLineItemUpdateInput!]
  connect: [ID!]
  disconnect: [ID!]
  delete: [ID!]
}

type OrderLineItemMeta {
  label: String
  value: String!
}

enum OrderLineItemOD1FileType {
  PDF
}

"""A paginated list of OrderLineItem items."""
type OrderLineItemPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of OrderLineItem items."""
  data: [OrderLineItem!]!
}

enum OrderLineItemPdfType {
  SMALL_PRODUCTION_LABEL
}

enum OrderLineItemProdCellFileType {
  POST_WELDING
}

type OrderLineItemProductFeature {
  id: ID!
  order_line_item_id: ID!
  product_feature_id: ID!
  name_suffix: String!
  description: String!
  additional_price: Float!
  additional_labor_cost: Float!
  lineItem: OrderLineItem!
  productFeature: ProductFeature!
}

type OrderLineItemProductionStepSummary {
  id: ID!
  prc: Int!
  prc_start_date: Date
  prc_end_date: Date
  in_process_wood: Int!
  in_process_wood_start_date: Date
  in_process_wood_end_date: Date
  final_wood: Int!
  final_wood_start_date: Date
  final_wood_end_date: Date
  finish_prep: Int!
  finish_prep_start_date: Date
  finish_prep_end_date: Date
  finish_stain: Int!
  finish_stain_start_date: Date
  finish_stain_end_date: Date
  finish_complete: Int!
  finish_complete_start_date: Date
  finish_complete_end_date: Date
  packed_wood: Int!
  packed_wood_start_date: Date
  packed_wood_end_date: Date
  metal_post_started: Int!
  metal_post_started_start_date: Date
  metal_post_started_end_date: Date
  metal_post_scanned_mill: Int!
  metal_post_scanned_mill_start_date: Date
  metal_post_scanned_mill_end_date: Date
  metal_post_dotpeened: Int!
  metal_post_dotpeened_start_date: Date
  metal_post_dotpeened_end_date: Date
  in_process_metal: Int!
  in_process_metal_start_date: Date
  in_process_metal_end_date: Date
  finished: Int!
  finished_start_date: Date
  finished_end_date: Date
  packed_metal: Int!
  packed_metal_start_date: Date
  packed_metal_end_date: Date
  glass_cut_and_break: Int!
  glass_cut_and_break_start_date: Date
  glass_cut_and_break_end_date: Date
  glass_edging: Int!
  glass_edging_start_date: Date
  glass_edging_end_date: Date
  glass_lamination: Int!
  glass_lamination_start_date: Date
  glass_lamination_end_date: Date
  glass_tempering: Int!
  glass_tempering_start_date: Date
  glass_tempering_end_date: Date
  glass_packed: Int!
  glass_packed_start_date: Date
  glass_packed_end_date: Date
  crate_in_process: Int!
  crate_in_process_start_date: Date
  crate_in_process_end_date: Date
  crate_built: Int!
  crate_built_start_date: Date
  crate_built_end_date: Date
}

input OrderLineItemQueryInput {
  small_parts_prep: Boolean
}

input OrderLineItemRelation {
  create: [OrderLineItemCreateInput!]
  update: [OrderLineItemUpdateInput!]
  upsert: [OrderLineItemUpsertInput!]
  delete: [ID!]
}

input OrderLineItemUpdateInput {
  id: ID!
  name: String
  order_id: ID
  price: Float
  quantity: Int
  finish_price: Float
  description: String
  item_notes: String
  customer_notes: String
  post_numbers_list: String
  percent_discount: Float
  expiration_date: DateTime
  fallback_percent_discount: Float
  finish_option_id: ID
  parent_line_item_id: ID
  is_custom: Boolean
  order_line_item_group_id: ID
  group_sort: Int
  product_id: ID
  exceptions: ItemExceptionUpdateRelation
  features: ProductFeatureRelation
  product: LineItemProductRelation
  glass_panel_numbers_list: String
  itemGroup: OrderLineItemGroupItemsRelation
}

input OrderLineItemUpsertInput {
  id: ID
  order_line_item_group_id: ID
  name: String
  description: String
  item_notes: String
  customer_notes: String
  post_numbers_list: String
  handrail_numbers_list: String
  glass_panel_numbers_list: String
  rod_numbers_list: String
  stringers_numbers_list: String
  order_id: ID
  quantity: Int
  shipped_quantity: Int
  product_id: ID
  group_sort: Int
  price: Float
  percent_discount: Float
  finish_price: Float
  finish_option_id: ID
  post_angle: Float
  expiration_date: Date
  fallback_percent_discount: Float
  special: Boolean
  exceptions: ItemExceptionUpdateRelation
  children: OrderLineItemChildrenRelation
  features: ProductFeatureRelation
  product: LineItemProductRelation
}

input OrderLineItemsQueryInput {
  metalBumpOutDashboard: metalBumpOutDashboardInput
  specialOrderItems: SpecialOrderItemsInput
}

input OrderPackageRelation {
  create: [PackageCreateInput!]
  update: [PackageUpdateInput!]
  delete: [ID!]
}

"""A paginated list of Order items."""
type OrderPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Order items."""
  data: [Order!]!
}

enum OrderPdfTypes {
  ORDER_AUTOBAG_LABELS
  ORDER_UNBAGGABLE_LABELS
  ORDER_PTL_LABEL
  ORDER_POST_BOX_LABELS
  ORDER_RAIL_TABLE
  ORDER_EXCEPTIONS_LABEL
  ORDER_PRODUCTION_ACTIVITY
  ORDER_CANADA_INVOICE
}

enum OrderPieceType {
  PieceId
  PieceBarcode
}

type OrderPriceTotals {
  orderWeight: Float!
  subtotal: Float!
  subtotalItemsOnly: Float!
  subtotalItemsServicesOnly: Float!
  salesTaxRate: Float!
  servicesTaxRate: Float!
  freightChargeTaxRate: Float!
  freightCharge: Float!
  liftgatePrice: Float!
  freightTax: Float!
  salesTax: Float!
  total: Float!
  shippingSubtotal: Float!
}

type OrderProductTypeGroupSchedule {
  id: ID!
  order_id: ID!
  od1_product_type_group_id: ID!
  production_date: Date!
  order: Order!
  od1ProductTypeGroup: OD1ProductTypeGroup!
}

input OrderProductTypeGroupScheduleFilter {
  order_ids: [ID!]
  production_dates: [Date!]
  od1_product_type_group_ids: [ID!]
}

input OrderProductTypeGroupScheduleScopeFilter {
  od1_product_type_group_ids: [ID!]!
  production_date: Date!
}

input OrderQueryCrateProductionFilter {
  od1ProductTypeIds: [ID!]!
  from: Date
  to: Date!
}

input OrderQueryGateProductionFilter {
  productTypeGroupIds: [ID!]
}

"""
Custom queries designed for a single use go here. Such as a query for a specific production dashboard not used in any
other cells.
"""
input OrderQueryInput {
  dotpeener_dashboard: Boolean
  crateProductionDashboard: OrderQueryCrateProductionFilter
  postPackingDashboard: Boolean
  gateProductionDashboard: OrderQueryGateProductionFilter
}

type OrderQuote {
  id: ID!
  order_id: ID!
  order: Order
  shipping_address_id: ID
  shippingAddress: Address
  shipping_method_id: ID
  shippingMethod: ShippingMethod
  shipping_charge: Float
  item_tax: Float
  shipping_tax: Float
  created_at: DateTime!
  updated_at: DateTime!
}

type OrderRemake {
  id: ID!
  order_id: ID!
  from_order_id: ID!
  remake_notes: String!
  order: Order!
  fromOrder: Order!
  reasons: [OrderRemakeReason!]!
  lineItems: [OrderLineItem!]!
}

input OrderRemakeLineItemRelationInput {
  connect: [ID!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input OrderRemakeOrderRelationInput {
  connect: ID
  create: OrderCreateInput
  update: OrderUpdateInput
  disconnect: Boolean
  delete: Boolean
}

type OrderRemakeReason {
  id: ID!
  order_remake_id: ID!
  remake_process_id: ID
  remake_reason_id: ID
  remake_sub_reason_id: ID
}

input OrderRemakeReasonRelationInput {
  create: [CreateOrderRemakeReasonRelation!]
  connect: [ID!]
  update: [UpdateOrderRemakeReason!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  delete: [ID!]
  disconnect: [ID!]
}

enum OrderRequestPackingField {
  HPC
  SmallPartsPrep
  SmallPartsPacking
}

input OrderSearchInput {
  id: String
  job_name: String
  shipping_name: String
  shipping_email: String
  shipping_city: String
  shipping_state: String
  shipping_zip: String
  project_manager_name: String
  sales_employee_name: String
  shipment_date_from: Date
  shipment_date_to: Date
  released_date_from: Date
  released_date_to: Date
  statuses: [OrderStatusEnum!]
}

input OrderShipmentRelation {
  create: [ShipmentCreateInput!]
  update: [ShipmentUpdateInput!]
  delete: [ID!]
}

type OrderStatus {
  id: ID!
  order_id: ID!
  order_status_id: OrderStatusEnum!
  status: OrderStatusEnum!
  created_at: DateTime!
  updated_at: DateTime!
  user_id: ID
}

enum OrderStatusEnum {
  ORDERED
  RELEASED
  IN_PRODUCTION
  IN_PACKING
  IN_SHIPPING
  SHIPPED
  CANCELED
}

input OrderStatusFilter {
  order_status_id: ID
}

enum OrderType {
  Standard
  Sample
  NoChargeRemake
  PartialChargeRemake
}

enum OrderURLType {
  ORDER_STATUS
  RGA_RETURN_LINK
}

input OrderUpdateInput {
  id: ID!
  order_group_id: ID
  deal_id: ID
  order_type_id: OrderType
  estimated_shipping_cost: Float
  actual_shipping_cost: Float
  shipping_charge: Float
  shipping_method_id: ID
  remake_of_order_id: ID
  payment_method_id: ID
  payment_term_id: ID
  user_id: ID
  billing_address_id: ID
  shipping_address_id: ID
  final_shipping_address_id: ID
  shipping_notes: String
  shipping_directions: String
  production_engineering_required_wood: Boolean
  production_engineering_required_glass: Boolean
  production_engineering_required_fabrication: Boolean
  production_engineering_complete: Boolean
  production_engineering_complete_wood: Boolean
  production_engineering_complete_glass: Boolean
  production_engineering_complete_fabrication: Boolean
  expected_ship_date: Date
  ship_after_date: Date
  due_date: Date
  delivery_window_from: Date
  delivery_window_to: Date
  metal_final_date: Date
  glass_final_date: Date
  flight_final_date: Date
  wood_final_date: Date
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
  hpc_request_time: DateTime
  smallparts_prep_request_time: DateTime
  smallparts_packing_request_time: DateTime
  building_id: ID
  remake_notes: String
  priority_production_notes: String
  secondary_production_notes: String
  addresses: OrderAddressRelation
  shipments: OrderShipmentRelation
  packages: OrderPackageRelation
  groups: OrderGroupRelation
  items: OrderLineItemRelation
}

"""
The type of contents a packing container is designated to hold.

In the packing container PutToLight (PTL) system, containers are made
available to hold items for all combination of some variables. One of those
variables is either a shipping method or a product, and the other is a vague
grouping based on the type of item, which this enum represents.

For example, out of all of their containers, they might have 3 separate ones
in use all heading to the same warehouse. Each of those 3 would have a
different PTLContainerType though, where one would be for all the posts,
another for all the handrails, and a third one for small parts boxes.

This info is stored exclusively on the label printed for the container, not
in any tables in the DB. We then read that info for verification purposes at
a later time in the PTL flow.
"""
enum PTLContainerType {
  POST
  HANDRAIL
  SMALL_PARTS
}

input PackMetalHandrailInput {
  """
  The production item id or related value.
  Can be in the following forms: '0000000' || Epc || Barcode || {"i":0000000}
  """
  production_item: String!

  """
  The order id can be optionally passed to ensure the production item belongs to the order.
  An error will be thrown if the production item does not belong to the order.
  """
  order_id: ID
}

input PackPackableItemInput {
  id: ID!
  package_id: ID!
  quantity_to_add: Int!
}

enum PackType {
  PACK
  UNPACK
}

union Packable = Product | OrderLineItem

type PackableItem {
  id: ID!
  order_id: ID!
  order: Order!
  packable_id: ID!
  packable_type: RelationType!
  packable: Packable!
  quantity: Int!
  quantity_packed: Int!
  product: Product
  getProduct: Product
  lineItem: OrderLineItem
  getPackableName: String!
  relationType: String
  name: String!
  notes: String
  bin_location: String
  pick_to_light_device_id: String
  packableItemsPivots: [PackableItemPackagePivot!]!
  show_barcode: Boolean!
  productGroup: ProductGroup
  productionType: ProductionType
  od1ProductType: OD1ProductType
  od1ProductGroup: OD1ProductTypeGroup
  itemType: PackableItemType

  """
  Returns the finishes for the line items probably associated with this packable item.
  Will be deprecated / removed in the future.
  """
  lineItemFinishes: String

  """
  Return the line item(s) that this item is or could potentially be attributed to. In the event of an optimized item
  this could return more than one line item with that piece on it.
  """
  potentialLineItems: [OrderLineItem!]!

  """
  Uses the potential line items to determine if we have an open exception.
  """
  hasOpenException: Boolean!
  isReturnable: Boolean!

  """
  Looks at the line items (or potential line items, if optimized) of this packable and determines refund amount.
  """
  returnPrices: [Float!]
  pdfLink(type: PdfTypes!): String!
  getStringerVoeId: String
}

input PackableItemFilter {
  id: ID
  upc: String
  type: PackableItemType
  isPacked: Boolean
  hasHandrail: Boolean
}

type PackableItemPackagePivot {
  id: ID!
  packable_item_id: ID!
  package_id: ID!
  quantity: Int!
  created_at: DateTime
  updated_at: DateTime
}

enum PackableItemType {
  HPC
  WOOD
  METAL
  FLIGHT
  GLASS
  STOCK
  SMALL_PARTS
  SMALL_PARTS_BRUSHED
  DROPSHIP
  VIRTUAL
  LG_STOCK
}

enum PackablePdfType {
  AUTOBAG_LABELS
  SMALL_PARTS_UNBAGGABLE
  STRINGER_LABELS
}

type Package {
  id: ID!
  number: Int
  complete: Boolean!
  order_id: ID
  order: Order
  shipment_id: ID
  currentLocation: Location
  locationHistory: [LocationAssignment!]!
  vrdInfo: VRDPackage
  package_id: ID
  packedIn: Package
  ancestors: [Package!]!
  ancestorsAndSelf: [Package!]!
  packing_bay_id: ID
  packingBay: PackingBay
  building_id: ID
  building: Building
  planned_location_id: ID
  plannedLocation: Location
  box_type: PackageType
  isOrderAgnostic: Boolean!
  length: Float
  width: Float
  height: Float
  weight: Float
  shipping_class: Float

  """Holds the cell / filter this package was created under or grouped by."""
  cell: String
  tracking_code: String
  created_at: DateTime
  updated_at: DateTime

  """
  Finds the closest shipment associated with this package. Either directly through the shipment relation, or through a
  parent package.
  """
  findShipment: Shipment
  name: String!
  contents: [Package!]!
  packableItems: [PackableItem!]!
  packableItemsPivots: [PackableItemPackagePivot!]!
  updatedPackableItems: [PackableItem!]!

  """
  Returns the number of packable items, not individual pieces, packed inside this package.
  """
  packedItemsQuantity: Int!
  packedPackagesQuantity: Int!

  """
  The ProductionItem this package is associated with - eg: when a crate is built the package _is_ the crate.
  """
  productionItem: ProductionItem
  canEdit: Boolean!
  canEditMessages: [String!]!
  costEstimate: Float!
  files: [File!]!

  """
  Checks to see if this package has shipped (assigned a shipment that has shipped) or not.
  """
  isShipped: Boolean
  metalRailDims: AutocalculatePackage
  rodDims: AutocalculatePackage
  stringerDims(length: Float): AutocalculatePackage
  stringerVoeIds: [String!]!
  containsHazMat: Boolean!
  pdfLink(type: PackagePdfType!): String!
  readyToShip: Boolean!
  hasOnlySSRails: Boolean!
  audits: [Audit!]!
}

input PackageContentsRelation {
  create: [PackageCreateInput!]
  update: [PackageUpdateInput!]
  delete: [ID!]
}

input PackageCreateInput {
  number: Int
  complete: Boolean
  order_id: ID
  shipment_id: ID
  packing_bay_id: ID
  building_id: ID
  planned_location_id: ID
  box_type: PackageType
  length: Float
  width: Float
  height: Float
  weight: Float
  shipping_class: Float
  cell: String
  tracking_code: String
  contents: PackageContentsRelation
}

input PackageFilter {
  id: ID
  ids: [ID!]
  shipment_id: ID

  """
  Filter by whether a package has a shipment or not (shipment_id = null).
  The @where on this initially looks wrong, but is actually correct due to the behavior of whereNull.
  """
  hasShipmentId: Boolean
  orderBy: [OrderByClause]
  box_type: [PackageType!]
  orderAgnostic: Boolean
}

input PackageItemInput {
  id: ID!
  items: [PackageLineItemQuantityInput!]!
}

input PackageLineItemQuantityInput {
  """ID Of the PackableItem to be packed"""
  id: ID

  """
  ID of the product being scanned which exists on a PackableItem on this order
  """
  product_id: ID

  """
  Barcode value for this product. Could be either product ID or HPC value (if
  set). Will find in that order and return a matching product.
  """
  barcode: String

  """
  ID of the ItemPiece (from OD1) being sent. Will be used to match a line item ID.
  """
  piece_id: ID

  """
  Barcode of the ItemPiece (from OD1) being sent. Will be used to match a line item ID.
  """
  piece_barcode: String
  quantity: Int!
}

"""A paginated list of Package items."""
type PackagePaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Package items."""
  data: [Package!]!
}

enum PackagePdfType {
  PACKING_LABELS
  STRINGER_LABELS
  STRINGER_LED_LABELS
}

enum PackageType {
  Box
  Envelope
  Mailer
  Skid
  Crate
  Tube
  Bag

  """An individually wrapped handrail"""
  Handrail

  """A box containing a stringer tube"""
  Stringer
  Gaylord
  HandrailRack

  """A box from the cold seal machine"""
  ColdSealBox
}

type PackageTypeInfo {
  type: PackageType!
  name: String!
}

input PackageTypesFilter {
  orderAgnostic: Boolean
  canBeNested: Boolean
}

input PackageUpdateInput {
  id: ID!
  number: Int
  complete: Boolean
  order_id: ID
  shipment_id: ID
  packing_bay_id: ID
  building_id: ID
  planned_location_id: ID
  box_type: PackageType
  length: Float
  width: Float
  height: Float
  weight: Float
  shipping_class: Float
  cell: String
  tracking_code: String
  contents: PackageContentsRelation
}

type PackedItem {
  id: ID!
  line_item_id: ID!
  quantity: Int!
  date_packed: DateTime
}

type PackingBay {
  id: ID!
  name: String!
}

input PackingBayFilter {
  id: String
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of PackingBay items."""
type PackingBayPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of PackingBay items."""
  data: [PackingBay!]!
}

input PackingContainerInfoFromScanInput {
  production_item_id: ID
  package_id: ID!
}

type PackingContainerInfoFromScanResult {
  type: PTLContainerType!
  shippingMethod: ShippingMethod
  product: Product
  isExpress: Boolean!
}

"""Information about pagination using a Relay style cursor connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """The cursor to continue paginating backwards."""
  startCursor: String

  """The cursor to continue paginating forwards."""
  endCursor: String

  """Total number of nodes in the paginated connection."""
  total: Int!

  """Number of nodes in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the last available page."""
  lastPage: Int!
}

"""Information about pagination using a fully featured paginator."""
type PaginatorInfo {
  """Number of items in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the first item in the current page."""
  firstItem: Int

  """Are there more pages after this one?"""
  hasMorePages: Boolean!

  """Index of the last item in the current page."""
  lastItem: Int

  """Index of the last available page."""
  lastPage: Int!

  """Number of items per page."""
  perPage: Int!

  """Number of total available items."""
  total: Int!
}

type PaintTouchUp {
  order_number: ID!
  order_line_items_quantity: Int!
  production_item_steps_finish_complete: Int!
  wood_final_date: Date
  exceptions: WoodExceptions!
}

type PaymentMethod {
  id: ID!
  name: String!
}

enum PaymentProcessType {
  Charge
  Authorize
}

type PaymentTerm {
  id: ID!
  name: String!
}

input PaymentTermFilter {
  ids: [ID!]
}

enum PdfTypes {
  AUTOBAG_LABELS
  SM_PARTS_UNBAGGABLE
  STRINGER_LABELS
}

type Permission {
  id: ID!
  name: String!
  group: String
  description: String
  enum: PermissionEnum!
  created_at: DateTime
  updated_at: DateTime
}

enum PermissionEnum {
  view_rules
  edit_rules
  view_shipping
  edit_shipping
  void_shipments
  reset_shipments
  view_users
  edit_users
  view_roles
  edit_roles
  view_products
  edit_products
  view_contacts
  edit_contacts
  view_companies
  edit_companies
  view_engineering
  edit_engineering
  view_production
  edit_production
  view_production_approvals
  edit_production_approvals
  view_exceptions
  edit_exceptions
  view_purchasing
  edit_purchasing
  view_deals
  edit_deals
  view_orders
  edit_orders
  view_transactions
  edit_transactions
  force_delete_orders
  schedule_production
  edit_production_scheduling_groups
  shipping_bypass_validation
  view_services
  vr_quotes_shipping_validation
  edit_packable_items
  view_packable_items
  complete_production_jobs
  request_small_parts_prep_jobs
  view_small_parts_prep
  manage_api_keys
  view_production_status
  edit_production_status
  view_production_activity
  view_production_wood
  view_production_metal
  view_production_flight
  view_production_glass
  view_production_crate
  view_maintenance_links
  reload_order
  view_rga_search
  view_logs
  view_admin
  edit_due_date_manager
  can_sync_orders
  edit_due_date
  delete_packages
  bulk_upload
  verbose_notifications
  create_order_line_items
  edit_order_line_items
  edit_delivery_window
  create_contacts
  create_addresses
  update_addresses
  create_deals
  add_files
  edit_notes
  edit_tags
  download_gql_schema
  create_orders
}

input PermissionRuleRelation {
  create: [CreatePermissionInput!]
  syncWithoutDetaching: [ID!]
  sync: [ID!]
  connect: [ID!]
}

type Piece {
  id: ID!
  product_id: ID!
  product: Product!
  piece_product_id: ID!
  pieceProduct: Product!
  quantity: Int!
}

input PieceFilter {
  has_kanban_bin_locations_like: String
}

type PiecePack {
  id: ID!
  product_id: ID!
  product: Product!
  piece_pack_product_id: ID!
  piecePackProduct: Product!
  quantity: Int!
}

type PostBracket {
  id: ID!
  name: String!
  active: Boolean!
  created_at: DateTime
  updated_at: DateTime
}

input PostBracketFilter {
  ids: [ID]
  name: String
  active: Boolean
}

type PostFootStyle {
  id: ID!
  name: String!
  active: Boolean!
}

input PostFootStyleFilter {
  name: String
  active: Boolean
}

type PostMountingStyle {
  id: ID!
  name: String!
  active: Boolean!
}

input PostMountingStyleFilter {
  active: Boolean
}

type PostSystemType {
  id: ID!
  name: String!
  active: Boolean!
}

input PostSystemTypeFilter {
  active: Boolean
  name: String
}

type PostTopStyle {
  id: ID!
  name: String!
  active: Boolean!
  post_bracket_id: ID
  post_top_type_id: ID
  material_id: ID
  postBracket: PostBracket
  postTopType: PostTopType
  material: Material
  created_at: DateTime
  updated_at: DateTime
}

input PostTopStyleFilter {
  id: String
  ids: [ID]
  name: String
  active: Boolean
  material_id: ID
  post_bracket_id: ID
  post_top_type_id: ID
}

type PostTopType {
  id: ID!
  name: String!
  active: Boolean!
  created_at: DateTime
  updated_at: DateTime
}

input PostTopTypeFilter {
  ids: [ID]
  name: String
  active: Boolean
}

enum PostType {
  NON_POST
  POST
  POST_INCLUDE
}

enum PrePackagingType {
  Box
  Bag
  Autobag
}

type Price {
  id: ID!
  product_id: Int!
  user_id: ID!
  price: Float!
  version: Date!
  created_at: DateTime!
  updated_at: DateTime!
  product: Product!
  user: User!
}

type PricingTier {
  id: ID!
  product: Product
  product_id: ID!
  tier_weight: Float
  tier_number: Int
  options: [AttributeOption!]!
}

input PricingTierOptionsRelation {
  sync: [ID]
}

type PrintLabelsReport {
  production_items_id: ID!
  order_line_items_id: ID!
  order_line_items_name: String
  materials_name: String
  production_items_piece_number: String
  order_line_items_quantity: Int
  step_date: DateTime
  exceptions: WoodExceptions!
}

"""
PHP constants representing the print types available for the print server.

TODO: Sync / automate generation using types from print server directly.
"""
enum PrintServerPDFType {
  autobag_labels
  autobag_product_labels
  bol
  bulk_pack
  files
  glass_talons
  labels
  pick_to_light
  post_label
  post_packing
  prc
  production_label_small
  ptl_1w
  qr_label
  reprint_glass_label
  reprint_label
  shipping_labels
  small_parts_unbaggable
  stringer_labels
  url
  weight_to_order
}

type PrintServerPrintRequest {
  """Packable ID of the installation binder on this order, if it exists."""
  binderPackableID: ID

  """
  Array of URLs to be printed for inclusion with the order during packing / shipping.
  """
  urls: [String!]!
}

input ProcessCreditCardTransactionInput {
  billing_address: AddressCreateInput
  credit_card: TransactionCreditCard!
  process_type: ProcessType!
  encrypted_csc: String
}

enum ProcessType {
  Charge
  Authorize
}

type Product {
  id: ID!
  name: String!
  customer_product_name: String
  customer_product_description: String
  price: Float!
  sale_price_percent: Float
  purchase_price: Float!
  purchase_price_included_products: Float
  labor_cost: Float!
  pre_finish_cost: Float!
  finish_price: Float!
  zero_price_when_mandatory: Boolean!
  instructions: String
  is_present_on_stairsupplies: String
  is_present_on_viewrail: String
  viewrail_image_url: String
  viewrail_slug: String
  stairsupplies_image_url: String
  stairsupplies_slug: String
  parent_id: ID
  od1_product_type_id: ID
  parent: Product
  children: [Product!]
  children_count: Int
  children_naming_scheme: String
  classification: ProductClassification!
  productFamily: ProductFamily
  product_family_id: ID
  group: ProductGroup
  type: ProductType
  od1Type: OD1ProductType
  od1Group: OD1ProductTypeGroup
  od1ProductionType: Od1ProductTypeProductionType
  postTopStyle: PostTopStyle
  postFootStyle: PostFootStyle
  post_cnc_program: String
  pricingTiers: [PricingTier!]!
  dimension: Dimension
  inventory: Inventory
  manufacturing: Manufacturing
  kanbanBins: [KanbanBin!]!
  attributes(filter: AttributeFilter): [Attribute!]!
  options: [AttributeOption!]!
  finishOptions: [FinishOption!]! @deprecated(reason: "This is not tested and currently does not work")
  materialName: String
  materialSize: MaterialSize
  material_size_id: ID
  manufacturingAttributes: [ManufacturingAttribute!]!
  vendors: [Vendor!]
  bundleRules: [BundleRule!]
  bundles: [Bundle!]!
  pieces(filter: PieceFilter): [Piece!]!
  piecePacks: [PiecePack!]!
  deleted_at: DateTime
  leadTime: Int
  globalSales: [GlobalSale!]!
  is_custom_product: Boolean!
  original_product_id: ID
  extendedProduct: Product
  product_status: ProductStatus!
  productionCharts: [ProductProductionChart!]!
  pivot: MetaProductPivot

  """Queries OD1 to determine if this product is marked as in-stock."""
  isInStock: Boolean!

  """
  Checks whether this item can be uniquely identified by a barcode / QR code on the item itself.
  """
  isUnidentifiableItem: Boolean!
  od1Files(type: OD1FileType): [OD1File!]!
  purchasingPart: PurchasingPart
  isHandrail: Boolean!
  handrail_length: Float
  stringer_length: Float
  is_haz_mat: Boolean!
  post_angle_required: Boolean
  post_configuration: String
  post_cut_angle: Int
  post_cut_length: Float
  post_distance_from_top_back: Float
  post_distance_from_top_front: Float
  post_distance_from_top_left: Float
  post_distance_from_top_right: Float
  post_has_postside_bracket_back: Boolean
  post_has_postside_bracket_front: Boolean
  post_has_postside_bracket_left: Boolean
  post_has_postside_bracket_right: Boolean
  post_hole_size_back: Float
  post_hole_size_front: Float
  post_hole_size_left: Float
  post_hole_size_right: Float
  post_inventor_configuration: String
  post_inventor_direction: String
  post_number_of_holes_back: Float
  post_number_of_holes_front: Float
  post_number_of_holes_left: Float
  post_number_of_holes_right: Float
  post_routing_instructions: String
  post_system_height: Float
  post_top_to_first_hole_back: Float
  post_top_to_first_hole_front: Float
  post_top_to_first_hole_left: Float
  post_top_to_first_hole_right: Float
  prepackaging_type: PrePackagingType
  wood_dim_material_id_1: ID
  wood_dim_material_id_2: ID
  wood_dim_material_id_3: ID
  wood_dim_material_id_4: ID
  woodDimMaterial1: Material
  woodDimMaterial2: Material
  woodDimMaterial3: Material
  woodDimMaterial4: Material
  wood_dim_material_size_id_1: ID
  wood_dim_material_size_id_2: ID
  wood_dim_material_size_id_3: ID
  wood_dim_material_size_id_4: ID
  woodDimMaterialSize1: MaterialSize
  woodDimMaterialSize2: MaterialSize
  woodDimMaterialSize3: MaterialSize
  woodDimMaterialSize4: MaterialSize
  wood_dim_prc_chop_1: Float
  wood_dim_prc_chop_2: Float
  wood_dim_prc_chop_3: Float
  wood_dim_prc_chop_4: Float
  wood_dim_chop_quantity_1: Float
  wood_dim_chop_quantity_2: Float
  wood_dim_chop_quantity_3: Float
  wood_dim_chop_quantity_4: Float
  wood_dim_rip_width_1: Float
  wood_dim_rip_width_2: Float
  wood_dim_rip_width_3: Float
  wood_dim_rip_width_4: Float
  wood_dim_plane_thickness_1: Float
  wood_dim_plane_thickness_2: Float
  wood_dim_plane_thickness_3: Float
  wood_dim_plane_thickness_4: Float
  wood_dim_glue_type_1: String
  wood_dim_glue_type_2: String
  wood_dim_glue_type_3: String
  wood_dim_glue_type_4: String
  wood_dim_final_width_1: Float
  wood_dim_final_width_2: Float
  wood_dim_final_width_3: Float
  wood_dim_final_width_4: Float
  wood_dim_final_length_1: Float
  wood_dim_final_length_2: Float
  wood_dim_final_length_3: Float
  wood_dim_final_length_4: Float
  wood_dim_final_height_1: Float
  wood_dim_final_height_2: Float
  wood_dim_final_height_3: Float
  wood_dim_final_height_4: Float
  glass_base: Float
  glass_height: Float
  glass_square_feet: Float
  glass_number_of_slots: Float
  glass_number_of_holes: Float
  board_footage: Float
  hasWoodFinalDimensions: Boolean!
  stock_out: Boolean!
  stock_out_date: DateTime
  stock_out_employee_id: ID
  material_id: ID
  website_image_override_url: String
  viewrail_website_url: String
  stairsupplies_website_url: String
  website_part_name: String
  customer_notes: String
  vr_part: String
  vendor_id: ID
  vendor: Vendor
  material: Material
  description: String
  default_finish_option_id: ID
  defaultFinishOption: FinishOption
  archived: Boolean!
  od1ProductType: OD1ProductType
  ship_as_freight: Boolean!
  auto_convert_to_special_on_import: Boolean!
  purchasing_vendor_part_number: String
  prevents_order_release: Boolean!
  shipping_class: Float
  rawMaterial: RawMaterial
  raw_material_id: ID
  raw_material_qty_per_unit: Int
  finish_group_id: ID
  is_installation_kit: Boolean
  is_hpc: Boolean
  handrail_profile: String
  files: [File!]!
  rightPrice(version: Date): Price
  rightPrices: [Price!]
  suggestedGroups: [SuggestedGroup]
  suggestedProducts: [Product]
  finishGroup: FinishGroup
}

enum ProductArchived {
  True
  False
  All
}

input ProductAttributeRelation {
  connect: [ID!]
  sync: [ID!]
  disconnect: [ID!]
}

input ProductBundlesRelation {
  upsert: [UpsertBundleInput!]
  delete: [ID!]
}

enum ProductClassification {
  Parent
  Child
  Simple
  Meta
  Piece
}

type ProductCustomization {
  id: ID!
  name: String!
  name_suffix: String!
  description_prefix: String!
  additional_price: Float!
  additional_labor_cost: Float!
  archived: Boolean!
  accounting_type_id: ID!
  od1ProductTypeAccountingType: Od1ProductTypeAccountingType
  od1ProductTypes: [OD1ProductType]
  created_at: DateTime
  updated_at: DateTime
}

input ProductCustomizationFilter {
  id: ID
  ids: [ID]
  name: String
  accounting_type_id: ID
  archived: Boolean
}

input ProductCustomizationOd1ProductTypeRelation {
  connect: [ID!]
  disconnect: [ID!]
}

input ProductDimensionRelation {
  connect: ID
  create: CreateDimensionInput
  update: UpdateDimensionInput
}

type ProductFamily {
  id: ID!
  name: String!
  process_time: Int
  buffer_time: Int
  customization_prefix: String
  dropship: Boolean
  customizable: Boolean
  discountable: Boolean
  deleted_at: DateTime
  productType: ProductType
  product_type_id: ID
  products: [Product!]!
  attributes: [Attribute!]!
  manufacturingAttributes: [ManufacturingAttribute!]!
  globalSales: [GlobalSale!]!
  features: [ProductFeature!]!
}

input ProductFamilyAddressRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  create: [AddressCreateInput!]
  update: [AddressUpdateInput!]
}

input ProductFamilyAttributeRelation {
  sync: [ID!]
}

input ProductFamilyManufacturingAttributeRelation {
  sync: [ID!]
}

type ProductFeature {
  id: ID!
  name: String!
  name_suffix: String
  description: String!
  additional_price: Float!
  additional_labor_cost: Float!
  od1_accounting_type_id: ID
  active: Boolean!
  post_cnc_program_suffix: String
  name_suffix_price_sync: String
  od1ProductTypes: [OD1ProductType]
  od1ProductTypeAccountingType: Od1ProductTypeAccountingType

  """Items below are untested, possibly deprecated"""
  lineItems: [OrderLineItem!]!
  families: [ProductFamily!]!
}

input ProductFeatureFilter {
  ids: [ID]
  keywords: String
  active: Boolean
  od1_accounting_type_id: ID
}

input ProductFeatureOd1ProductTypeRelation {
  connect: [ID!]
  disconnect: [ID!]
}

input ProductFeatureRelation {
  create: [CreateProductFeature!]
  connect: [ID!]
  update: [UpdateProductFeature!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  delete: [ID!]
  disconnect: [ID!]
}

input ProductFilter {
  id: String
  ids: [ID]
  name: String
  classification: ProductClassification
  classifications: [ProductClassification]
  parent_id: ID
  product_status: ProductStatus
  is_custom_product: Boolean
  is_hpc: Boolean
  is_installation_kit: Boolean
  product_type: ID

  """
  Filter items by bin locations matching the requested string.
  Passing any 'like' strings to filter by. Ex: "1W-PC%" would filter items by
  those with bin locations starting with "1W-PC".
  """
  has_kanban_bin_locations_like: String
  material_id: ID
  material_ids: [ID!]
  od1_type: ID
  od1_product_type_ids: [ID!]
  vendor_ids: [ID!]

  """Filter items by name or description"""
  keywords: String
  archived: ProductArchived
  handrail_profile: String
  handrail_length: Float
  post_top_style_id: ID
  post_foot_style_id: ID
  post_inventor_configuration: String
  post_inventor_direction: String
  post_system_height: Float
  post_system_type_id: ID
}

type ProductGroup {
  id: ID!
  name: String!
  process_time: Int
  buffer_time: Int
  engineering_lead_time: Int
  deleted_at: DateTime
  productTypes: [ProductType!]!
  attributes: [Attribute!]!
  globalSales: [GlobalSale!]!
}

input ProductGroupAttributeRelation {
  sync: [ID!]
}

input ProductInventoryRelation {
  connect: ID
  create: CreateInventoryInput
  update: UpdateInventoryInput
}

input ProductManufacturingAttributeRelation {
  connect: [ID!]
  sync: [ID!]
  disconnect: [ID!]
}

input ProductManufacturingRelation {
  connect: ID
  create: CreateManufacturingInput
  update: UpdateManufacturingInput
  upsert: UpsertManufacturingInput
}

input ProductOptionRelation {
  sync: [ID!]
  disconnect: [ID!]
}

"""A paginated list of Product items."""
type ProductPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Product items."""
  data: [Product!]!
}

input ProductPiecePacksRelation {
  upsert: [UpsertPiecePackInput!]
  delete: [ID!]
}

input ProductPiecesRelation {
  upsert: [UpsertPieceInput!]
  delete: [ID!]
}

input ProductPostFootStyleRelation {
  connect: ID
}

input ProductPostTopStyleRelation {
  connect: ID
}

type ProductProductionChart {
  id: ID!
  product_id: ID!
  thickness: Float
  length: Float
  depth: Float
  final_thickness: Float
  final_length: Float
  final_depth: Float
  chop_quantity: Float
  glue_type: String
  product: Product!
}

input ProductProductionChartRelation {
  create: [CreateProductProductionChart!]
  update: [UpdateProductProductionChart!]
  upsert: [UpsertProductProductionChart!]
  delete: [ID!]
}

enum ProductStatus {
  Prototype
  PreRelease
  Live
}

input ProductSuggestedGroupRelation {
  connect: [ID!]
  disconnect: [ID!]
  update: UpdateProductSuggestedGroupInput
  create: CreateProductSuggestedGroupInput
}

type ProductType {
  id: ID!
  name: String!
  enumerate: Boolean
  process_time: Int
  buffer_time: Int
  capacity: Int
  deleted_at: DateTime
  productGroup: ProductGroup
  product_group_id: ID
  productFamilies: [ProductFamily!]!
  attributes: [Attribute!]!
  globalSales: [GlobalSale!]!
}

input ProductTypeAttributeRelation {
  sync: [ID!]
}

type ProductTypePackedHistoricalType {
  day: DateTime!
  count: Int!
}

type ProductTypePackedType {
  count: Int!
}

"""Holds all date order / filter by options for sorting results."""
enum ProductionActivityDateFromToFilterType {
  PrcDate
  FinalDate
  WoodProductionDate
  WoodFinalDate
  FinishDate
  PackedDate
  MetalProductionDate
  MetalFinalDate
  FlightProductionDate
  FlightFinalDate
  GlassFinalDate
  GlassProductionDate
  CutAndBreakDate
  DueDate
  ShippedDate
}

"""List of enums for ordering the results of this query."""
enum ProductionActivityDateOrderByType {
  MetalProductionDate
  ProductionNotesAndMetalProductionDate
  OrderFlightDate
  FlightProductionDate
  ProductionNotesAndFlightProductionDate
  WoodProductionDate
  ProductionNotesAndWoodProductionDate
  PrcChop
  GlassProductionDate
  ProductionNotesAndGlassProductionDate
  DueDate
  Material
  CustomerCompany
  ShippingMethod
  ProductionNotesAndDueDate
  ReleasedDate
}

"""
Holds the filters for date type filters (including certain production types,
released only, etc). Multiple can be selected at a time.
"""
enum ProductionActivityFilterDateOptionType {
  ShowShippedOrdersAndProducts
  ShowOnlyRemakes
  ShowOnlyWithoutSecondaryPriorityNotes
}

"""
Holds the filters for date type filters (including certain production types,
released only, etc). Only one can be selected at a time.
"""
enum ProductionActivityFilterDateType {
  AllMetalProductionDates
  WithoutMetalProductionDate
  WithoutFlightProductionDate
  AllWoodProductionDates
  WithoutWoodProductionDate
  AllGlassProductionDates
  WithoutGlassProductionDate
  AllReleased
  ShowPrcItems
  HidePrcItems
}

"""Report for various production activity screens in terminal."""
type ProductionActivityReport {
  oli_id: ID!
  name: String!
  finish_name: String
  quantity: Int!
  shipped_quantity: Int!
  price: Float!
  total_price: Float!
  finish_price: Float!
  total_finish_price: Float!
  order_number: String!
  shipping_method: String
  priority_production_notes: String
  is_remake: Boolean!
  remake_notes: String
  wood_dim_prc_chop_1: Float
  material_name: String
  material_size_name: String
  board_footage: Float
  wood_dim_rip_width_1: Float
  wood_dim_plane_thickness_1: Float
  wood_dim_chop_quantity_1: Float
  has_open_exceptions: Boolean
  due_date: Date
  released_date: Date
  shipped_date: Date
  metal_final_date: Date
  glass_final_date: Date
  flight_final_date: Date
  wood_final_date: Date
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
  prc_done: Int!
  prc_done_date: DateTime
  in_process_wood_done: Int!
  in_process_wood_done_date: DateTime
  final_wood_done: Int!
  final_wood_done_date: DateTime
  finish_prep_done: Int!
  finish_prep_done_date: DateTime
  finish_stain_done: Int!
  finish_stain_done_date: DateTime
  finish_complete_done: Int!
  finish_complete_done_date: DateTime
  packed_wood_done: Int!
  packed_wood_done_date: DateTime
  in_process_metal_done: Int!
  in_process_metal_done_date: DateTime
  finished_done: Int!
  finished_done_date: DateTime
  packed_metal_done: Int!
  packed_metal_done_date: DateTime
  glass_cut_and_break_done: Int!
  glass_cut_and_break_done_date: DateTime
  glass_edging_done: Int!
  glass_edging_done_date: DateTime
  glass_lamination_done: Int!
  glass_lamination_done_date: DateTime
  glass_tempering_done: Int!
  glass_tempering_done_date: DateTime
  glass_packed_done: Int!
  glass_packed_done_date: DateTime
  crate_in_process_done: Int!
  crate_in_process_done_date: DateTime
  crate_built_done: Int!
  crate_built_done_date: DateTime
}

input ProductionActivityReportInput {
  """
  Filter report by specific product type group IDs. Atleast one is required.
  """
  productTypeGroupIds: [ID!]

  """The filtering start date for the requested column."""
  dateFrom: Date

  """The filtering end date for the requested column."""
  dateTo: Date

  """
  The column / type we should be filtering by for the supplied dates. Required when date from or to is set.
  """
  dateFromToFilterType: ProductionActivityDateFromToFilterType

  """How we should order the results."""
  dateOrderBy: ProductionActivityDateOrderByType

  """
  The types of dates we should filter by in our responses (including certain production dates, excludes, etc).
  """
  dateFilterType: ProductionActivityFilterDateType

  """
  Additional / multi select for filtering dates and fields in our report.
  """
  dateFilterOptions: [ProductionActivityFilterDateOptionType!]

  """Specific materials we should filter by."""
  materialIds: [ID!]

  """Specific material sizes we should filter by."""
  materialSizeIds: [ID!]

  """Specific finish options we should filter by."""
  finishOptionIds: [ID!]

  """Hide items with these steps already complete."""
  hideCompleteSteps: [ProductionItemStepColumn!]

  """Specific shipping methods we should filter by."""
  shippingMethodIds: [ID!]
}

"""A paginated list of ProductionActivityReport items."""
type ProductionActivityReportPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of ProductionActivityReport items."""
  data: [ProductionActivityReport!]!
}

type ProductionBlockedDueDate {
  id: ID!
  date: Date!
  created_at: DateTime!
  updated_at: DateTime
  user: User!
}

type ProductionItem {
  id: ID!
  order_line_item_id: ID!
  piece_number: String!
  barcode: String!
  created_at: DateTime
  updated_at: DateTime
  lineItem: OrderLineItem!
  material: Material
  finishOption: FinishOption
  order: Order!
  package: Package
  productionItemStep: ProductionItemStep!
  product: Product!
  postTopStyle: PostTopStyle
  postFootStyle: PostFootStyle
  epcs: [Epc!]!
  subAssemblies: [SubAssembly!]!

  """Return all exceptions for this production item."""
  allExceptions(filter: ItemExceptionFilterInput): [ItemException!]!

  """Returns the active / open exception if there is one."""
  exception: ItemException
  epcQuantity: Int!
  od1Files: [OD1File!]!

  """
  Boolean for whether or not this item is packed into a package or not (by checking the packable piece).
  """
  isPacked: Boolean!

  """Check whether this production item has an open exception."""
  hasOpenException: Boolean!
  pdfLink(type: ProductionItemPdfType!): String
}

"""Must provide either a productionItemId or packageId"""
input ProductionItemCompleteStepInput {
  """
  ID for the specific production item to mark complete.
  Required if packageId not set.
  """
  productionItemId: ID

  """
  ID for the specific package associated with a piece to mark complete.
  Required if pieceId not set.
  """
  packageId: ID

  """Will attempt to parse the string and use the related production item."""
  scan: String
  step: ProductionItemStepColumn!
}

input ProductionItemFilterInput {
  orderBy: [OrderByClause!]
  postTypes: [PostType!]
  ids: [ID!]
  orderLineItemIds: [ID!]

  """Filter by one or more production steps that are complete."""
  stepsComplete: [ProductionItemStepColumn!]

  """Filter by one or more production steps that are incomplete."""
  stepsIncomplete: [ProductionItemStepColumn!]
}

"""A paginated list of ProductionItem items."""
type ProductionItemPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of ProductionItem items."""
  data: [ProductionItem!]!
}

enum ProductionItemPdfType {
  SMALL_PRODUCTION_LABEL
}

input ProductionItemQueryInput {
  metalHandrailDashboard: MetalHandrailDashboardFilter
  flightProductionItems: FlightProductionFilter
}

type ProductionItemStep {
  id: ID!
  production_item_id: ID!
  prc: DateTime
  prc_employee_id: ID
  in_process_wood: DateTime
  in_process_wood_employee_id: ID
  final_wood: DateTime
  final_wood_employee_id: ID
  finish_prep: DateTime
  finish_prep_employee_id: ID
  finish_stain: DateTime
  finish_stain_employee_id: ID
  finish_complete: DateTime
  finish_complete_employee_id: ID
  packed_wood: DateTime
  packed_wood_employee_id: ID
  metal_post_started: DateTime
  metal_post_started_employee_id: ID
  metal_post_scanned_mill: DateTime
  metal_post_scanned_mill_employee_id: ID
  metal_post_dotpeened: DateTime
  metal_post_dotpeened_employee_id: ID
  in_process_metal: DateTime
  in_process_metal_employee_id: ID
  finished: DateTime
  finished_employee_id: ID
  packed_metal: DateTime
  packed_metal_employee_id: ID
  glass_cut_and_break: DateTime
  glass_cut_and_break_employee_id: ID
  glass_edging: DateTime
  glass_edging_employee_id: ID
  glass_lamination: DateTime
  glass_lamination_employee_id: ID
  glass_tempering: DateTime
  glass_tempering_employee_id: ID
  glass_packed: DateTime
  glass_packed_employee_id: ID
  crate_in_process: DateTime
  crate_in_process_employee_id: ID
  crate_built: DateTime
  crate_built_employee_id: ID
  created_at: DateTime
  updated_at: DateTime
  prcUser: User
  inProcessWoodUser: User
  finalWoodUser: User
  finishPrepUser: User
  finishStainUser: User
  finishCompleteUser: User
  packedWoodUser: User
  inProcessMetalUser: User
  finishedUser: User
  packedMetalUser: User
  glassCutAndBreakUser: User
  glassEdgingUser: User
  glassLaminationUser: User
  glassTemperingUser: User
  glassPackedUser: User
  crateInProcessUser: User
  crateBuiltUser: User
  metalPostStartedUser: User
  metalPostScannedMillUser: User
  metalPostDotpeenedUser: User
  order: Order!
  productionItem: ProductionItem!
  audits: [Audit!]!
}

enum ProductionItemStepColumn {
  PRC
  IN_PROCESS_WOOD
  FINAL_WOOD
  FINISH_PREP
  FINISH_STAIN
  FINISH_COMPLETE
  PACKED_WOOD
  IN_PROCESS_METAL
  FINISHED
  PACKED_METAL
  GLASS_CUT_AND_BREAK
  GLASS_EDGING
  GLASS_LAMINATION
  GLASS_TEMPERING
  GLASS_PACKED
  CRATE_IN_PROCESS
  CRATE_BUILT
  METAL_POST_STARTED
  METAL_POST_SCANNED_MILL
  METAL_POST_DOTPEENED
}

type ProductionJob {
  id: ID!
  job_label: String
  order_id: ID!
  finish_option_id: ID
  production_type: ProductionJobType!

  """Column in the database representing the partial status."""
  partial: Boolean! @deprecated(reason: "Preferably use isPartial instead since the conditions for these checks could change in the future rather than just the column value.")

  """
  Whether or not this Production Job is partial. Currently checks the column, but could potentially additionally check
  other fields or statuses in the future.
  """
  isPartial: Boolean!
  completed_at: DateTime
  created_at: DateTime
  updated_at: DateTime
  isComplete: Boolean!
  order: Order!

  """
  Returns the line items from the attached order, filtered by the current job's finish option.
  """
  jobLineItems(filter: OrderLineItemFilterInput, query: OrderLineItemQueryInput): [OrderLineItem!]!
  finishOption: FinishOption
}

input ProductionJobFilter {
  production_type: ProductionJobType

  """
  Whether or not we should filter by completed only or not. True = only show completed, False = only show incomplete.
  """
  completed: Boolean
  orderBy: [OrderByClause!]
}

input ProductionJobQuery {
  small_parts_prep: ProductionJobQuerySmallPartsInput
}

input ProductionJobQuerySmallPartsInput {
  date: Date
}

enum ProductionJobType {
  SMALL_PARTS_PREP
}

"""Controller for building reports around production scheduling."""
type ProductionScheduleReport {
  order_number: String!
  board_footage: Float
  group_quantities: String!
  due_date: Date
  metal_final_date: Date
  glass_final_date: Date
  flight_final_date: Date
  wood_final_date: Date
  metal_production_date: Date
  wood_production_date: Date
  glass_production_date: Date
  flight_production_date: Date
}

input ProductionScheduleReportInput {
  """
  The types of dates we should filter by in our responses (including certain production dates, excludes, etc).
  """
  dateFilterType: ProductionActivityFilterDateType

  """One or more product type IDs we should query for, and aggregate by."""
  od1ProductTypeGroupIds: [ID!]!
}

"""A paginated list of ProductionScheduleReport items."""
type ProductionScheduleReportPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of ProductionScheduleReport items."""
  data: [ProductionScheduleReport!]!
}

type ProductionSchedulingGroup {
  id: ID!
  name: String!
  capacity: Int!
  label: String
  od1ProductTypeGroups: [OD1ProductTypeGroup!]!
}

type ProductionType {
  id: ID!
  name: String!
  internal_name: String!
}

"""
Type representing the static IDs of the production types so we can directly
compare specific types & validate on the frontend.
"""
enum ProductionTypeEnum {
  NotesAndDirections
  Wood
  Metal
  WoodStock
  MetalStock
  Glass
  Flight
  Dropship
  Crate
}

type PurchaseOrder {
  id: ID!
  purchase_order_status: PurchaseOrderStatus!
  created_by_id: ID!
  createdBy: User!
  purchase_order_notes: String
  shipping_cost: Float
  item_tax: Float
  due_date: Date
  received_on: Date
  total: Float
  vendor_id: ID!
  vendor: Vendor!
  lineItems: [PurchaseOrderLineItem!]!
  addresses: [Address!]!
  files: [File!]!
}

input PurchaseOrderAddressRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  create: [AddressCreateInput!]
  update: [AddressUpdateInput!]
}

input PurchaseOrderFilter {
  id: String
  ids: [ID]
  purchase_order_status: PurchaseOrderStatus
  vendor_id: ID
}

type PurchaseOrderLineItem {
  id: ID!
  purchase_order_id: ID!
  purchaseOrder: PurchaseOrder!
  vendor_part_id: ID
  vendorPart: VendorPart
  name: String
  description: String
  vendor_sku: String
  cost_account_id: ID
  costAccount: CostAccount
  department_id: ID
  department: Department

  """quantity: Int"""
  purchase_price: Float!
  reorder_quantity: Int
  requested_by_id: ID
  requestedBy: User
  requested_quantity: Int!
  received_quantity: Int
}

input PurchaseOrderLineItemRelation {
  create: [CreatePurchaseOrderLineItemInput!]
  update: [UpdatePurchaseOrderLineItemInput!]
  delete: [ID!]
}

"""A paginated list of PurchaseOrder items."""
type PurchaseOrderPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of PurchaseOrder items."""
  data: [PurchaseOrder!]!
}

enum PurchaseOrderStatus {
  Open
  Sent
  Received
  ReceivedShort
  Closed
}

type PurchasingPart {
  id: ID!
  name: String!
  description: String
  product: Product
  vendorParts: [VendorPart]!
  vendors: [Vendor]!
}

input PurchasingPartFilter {
  id: ID
  ids: [ID]
  name: String
  description: String
  product: ProductFilter
  vendor_part_ids: [ID]
  vendors: [ID]
  orderBy: [OrderByClause!]
}

"""A paginated list of PurchasingPart items."""
type PurchasingPartPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of PurchasingPart items."""
  data: [PurchasingPart!]!
}

input PurchasingPartRelation {
  create: CreatePurchasingPartInput!
  update: UpdatePurchasingPartInput!
  delete: ID!
}

type PurchasingPartRequest {
  id: ID!
  requested_by_id: ID!
  requestedBy: User!
  requested_on: Date!
  requested_quantity: Int!
  requested_status: RequestedPartStatus!
  requested_type: RequestedPartType!
  purchasing_part_id: ID
  purchasingPart: PurchasingPart
  vendors: [Vendor]!
  description: String
  purchase_price: Float
  due_date: Date!
}

input PurchasingPartRequestFilter {
  ids: [ID]
  requested_type: RequestedPartType
  requested_status: RequestedPartStatus
  vendors: [ID]
  orderBy: [OrderByClause!]
}

"""A paginated list of PurchasingPartRequest items."""
type PurchasingPartRequestPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of PurchasingPartRequest items."""
  data: [PurchasingPartRequest!]!
}

type Query {
  """
  Get an array of URLs (generally used for fallbacks) for all print jobs for this request.
  """
  printJobUrls(jobs: [JSON!]!): [String!]!
  schemaDump(input: SchemaDumpInput): String!
  search(input: SearchInput!): SearchResults
  vrdLocations(filter: VRDLocationFilter): [VRDLocation!]!
  address(id: ID!): Address
  addresses(filter: AddressFilter): [Address]!
  validateAddress(id: ID!): Address
  getShippingAddressFromOD1OrderNumber(order_number: String!): Address
  getFinalShippingAddressFromOD1OrderNumber(order_number: String!): Address
  appLog(id: ID!): AppLog
  appLogsSummary(input: AppLogsSummaryInput): AppLogsSummary!
  appLogsSummaryByUser: [AppLogsSummaryByUser!]
  appSetting(id: ID!): AppSetting
  appSettings: [AppSetting]!
  defaultGroundShippingMethod: ShippingMethodSetting
  defaultFreightShippingMethod: ShippingMethodSetting
  expressRestockShippingMethod: ShippingMethodSetting
  defaultDistributionCenter: DistributionCenterSetting
  woodSampleProductTypes: WoodSampleProductTypesSetting
  attribute(id: ID): Attribute
  allAttributes(filter: AttributeFilter): [Attribute!]!
  attributeOption(id: ID): AttributeOption
  attributeOptions(filter: AttributeOptionFilter): [AttributeOption!]!
  audit(id: ID!): Audit
  audits(filter: AuditFilter): [Audit!]!
  auditsForOrder(orderId: ID!): [Audit!]!
  brands: [Brand!]!
  building(id: ID!): Building
  buildings(filter: BuildingFilter): [Building!]!
  bundle(id: ID!): Bundle
  bundleGroup(id: ID!): BundleGroup
  bundleRule(id: ID): BundleRule
  bundleRuleProduct(id: ID!): BundleRuleProduct
  bundleType(id: ID!): BundleType
  bundleTypes: [BundleType!]!
  company(id: ID!): Company
  contact(id: ID!): Contact
  costAccount(id: ID!): CostAccount
  customerTypes: [CustomerType!]!
  deal(id: ID!): Deal
  department(id: ID!): Department
  dimension(product_id: ID): Dimension
  engineeringTask(id: ID!): EngineeringTask
  engineeringTasks(filter: EngineeringTaskFilter!): [EngineeringTask!]!
  engineeringTaskSteps: [EngineeringTaskStep!]!
  engineeringTaskTypes: [EngineeringTaskType!]!
  exceptionReasons: [ExceptionReason!]!
  file(id: ID!): File
  finishGroup(id: ID!): FinishGroup
  finishGroups(filter: FinishGroupFilter): [FinishGroup!]!
  finishOption(id: ID!): FinishOption
  finishOptionsResults(filter: FinishOptionFilter): [FinishOption!]!
  allFinishOptions(filter: FinishOptionFilter): [FinishOption!]!
  globalSale(id: ID!): GlobalSale
  globalSales(filter: GlobalSaleFilterInput): [GlobalSale!]!
  inventory(product_id: ID): Inventory
  itemException(id: ID!): ItemException
  itemExceptions(filter: ItemExceptionFilterInput): [ItemException!]!
  kanbanBin(id: ID): KanbanBin
  kanbanBins(input: KanbanFilter): [KanbanBin!]!
  leadTimes(input: leadTimesInput): [LeadTime!]!
  location(id: ID!): Location
  locationMarkup(zip: ID!): LocationMarkup
  manufacturing(product_id: ID): Manufacturing
  manufacturingAttribute(id: ID!): ManufacturingAttribute
  allManufacturingAttributes(filter: ManufacturingAttributeSearchFilter): [ManufacturingAttribute!]!
  manufacturingAttributeOption(id: ID!): ManufacturingAttributeOption
  manufacturingAttributeOptions: [ManufacturingAttributeOption!]!
  manufacturingParameter(id: ID!): ManufacturingParameter
  manufacturingParamByVoeId(voe_id: String!): ManufacturingParameter
  manufactureDataByLineItemId(order_line_item_id: ID!): ManufacturingParameter
  manufacturingParamsByVoeId(voe_id: String!): [ManufacturingParameter]!
  material(id: ID!): Material
  materials(filter: MaterialFilter): [Material!]!
  materialLength(id: ID!): MaterialLength
  materialLengths(filter: MaterialLengthFilterInput): [MaterialLength!]!
  materialSize(id: ID!): MaterialSize
  materialSizes(filter: MaterialSizesInput): [MaterialSize!]!
  materialType(id: ID!): MaterialType
  materialTypes(filter: MaterialTypesInput): [MaterialType!]!
  note(id: ID!): Note
  notes(filter: NoteFilterInput!): [Note]!
  od1Company(id: ID!): OD1Company
  od1File(id: ID!): OD1File
  od1ProductTypes(input: Od1ProductTypeInput): [OD1ProductType!]!
  od1ProductType(id: ID!): OD1ProductType
  allOd1ProductTypes(filter: OD1ProductTypeFilter): [OD1ProductType!]!
  od1ProductTypeAccountingTypes: [Od1ProductTypeAccountingType!]!
  od1ProductTypeGroup(id: ID!): OD1ProductTypeGroup
  od1ProductTypeGroups(filter: OD1ProductTypeGroupFilter): [OD1ProductTypeGroup!]!
  od1ProductTypeProductionTypes: [Od1ProductTypeProductionType!]!
  od1ProductTypeProductionType(id: ID!): Od1ProductTypeProductionType
  order(id: ID!): Order
  orderByNumber(order_number: String!): Order
  orderByPiece(value: String!, key: OrderPieceType!): Order
  orders(
    filter: OrderFilterInput

    """
    Which underlying query we should apply. These are usually built specifically for each dashboard when we have to
    many / custom queries.
    """
    query: OrderQueryInput
    where: QueryOrdersWhereWhereConditions
  ): [Order!]!
  orderGroup(id: ID!): OrderGroup
  orderGroups: [OrderGroup!]!
  lineItem(id: ID): OrderLineItem
  lineItems(filter: OrderLineItemFilterInput, query: OrderLineItemsQueryInput): [OrderLineItem!]!
  itemGroup(id: ID!): OrderLineItemGroup
  itemGroups: [OrderLineItemGroup!]!
  orderOrderProductTypeGroupSchedule(id: ID!): OrderProductTypeGroupSchedule
  orderOrderProductTypeGroupSchedules(filter: OrderProductTypeGroupScheduleFilter): [OrderProductTypeGroupSchedule!]!
  generateOrderQuote(id: ID!): OrderQuote
  orderRemake(id: ID!): OrderRemake
  remakeProcesses: [RemakeProcess!]!
  remakeReasons: [RemakeReason!]!
  remakeSubReasons: [RemakeSubReason!]!
  packableItem(id: ID!): PackableItem
  package(id: ID!): Package
  packages(filter: PackageFilter): [Package!]
  packageTypes(filter: PackageTypesFilter): [PackageTypeInfo!]
  packingContainerInfoFromScan(input: PackingContainerInfoFromScanInput!): PackingContainerInfoFromScanResult!
  packingBay(id: ID!): PackingBay

  """Returns a full list of all payment methods inside the system."""
  paymentMethods: [PaymentMethod!]!
  paymentTerm(id: ID!): PaymentTerm
  paymentTerms(filter: PaymentTermFilter): [PaymentTerm!]!
  permissions: [Permission!]!
  permission(id: ID!): Permission
  piece(id: ID): Piece
  pieces(filter: PieceFilter): [Piece!]
  piecePack(id: ID): Piece
  postBracket(id: ID!): PostBracket
  postBrackets(filter: PostBracketFilter): [PostBracket!]!
  postFootStyles(input: PostFootStyleFilter): [PostFootStyle!]!
  postMountingStyles(filter: PostMountingStyleFilter): [PostMountingStyle!]!
  postSystemTypes(filter: PostSystemTypeFilter): [PostSystemType!]!
  postTopStyle(id: ID!): PostTopStyle
  postTopStyles(filter: PostTopStyleFilter): [PostTopStyle!]!
  postTopType(id: ID!): PostTopType
  postTopTypes(filter: PostTopTypeFilter): [PostTopType!]!
  price(id: ID!): Price
  pricingTier(id: ID!): PricingTier
  product(id: ID): Product

  """
  Searches for a product by providing the value of the barcode. First compares against ID, then falls back to UPC.
  """
  productByBarcode(barcode: ID!): Product
  allProducts(filter: ProductFilter): [Product!]!

  """Use the od1_product_type_id to get the count packed today."""
  productTypePackedToday(
    """The od1_product_type_id."""
    od1_product_type_id: ID!
  ): ProductTypePackedType

  """
  Use the od1_product_type_id to get the count packed by day.
  By default it returns the current month.
  """
  productTypePackedHistoricalByDays(
    """The od1_product_type_id."""
    od1_product_type_id: ID!

    """
    The date time of the start date < end date time.
    If no start date is specified it defaults to beginning of month.
    """
    start_date: DateTime

    """
    The date time of the end date > start date time.
    If no end date is specified it defaults to today.
    """
    end_date: DateTime
  ): [ProductTypePackedHistoricalType!]!
  productCustomization(id: ID!): ProductCustomization
  productCustomizations(filter: ProductCustomizationFilter): [ProductCustomization!]!
  productFamily(id: ID): ProductFamily
  productFamilies: [ProductFamily!]!
  productFeature(id: ID!): ProductFeature
  productFeatures(input: ProductFeatureFilter): [ProductFeature!]!
  productGroup(id: ID): ProductGroup
  productGroups: [ProductGroup!]!
  productType(id: ID): ProductType
  productTypes: [ProductType!]!
  createOrDeleteProductionBlockedDueDate(date: Date): [ProductionBlockedDueDate!]!
  productionItem(id: ID!): ProductionItem

  """
  Used to find a production item by the order # and a piece # - using a post type or production type to filter further.
  """
  productionItemByNumber(
    orderNumber: String!

    """The piece number for this production item."""
    pieceNumber: String!

    """Optionally, whether we should filter by a specific post type."""
    postType: PostType

    """
    The production type IDs we should filter this search by since a piece number is not unique per order.
    """
    productionTypeIds: [ID!]
  ): ProductionItem

  """Can handle EPC, ID, and Barcodes"""
  productionItemByScan(scan: String!): ProductionItem
  productionItems(filter: ProductionItemFilterInput, query: ProductionItemQueryInput): [ProductionItem!]!
  productionItemByBarcode(barcode: String!): ProductionItem @deprecated(reason: "Use productionItemByScan()")
  productionItemStep(id: ID!): ProductionItemStep
  productionJob(id: ID!): ProductionJob
  productionJobs(filter: ProductionJobFilter, query: ProductionJobQuery): [ProductionJob!]!
  productionSchedulingGroups: [ProductionSchedulingGroup!]!
  purchaseOrder(id: ID!): PurchaseOrder
  purchaseOrderLineItem(id: ID!): PurchaseOrderLineItem
  purchaseOrderLineItems: [PurchaseOrderLineItem!]!
  purchasingPart(id: ID): PurchasingPart
  purchasingPartRequest(id: ID): PurchasingPartRequest
  rgaRequests(filter: FilterRGARequestsInput): [RGARequest!]!
  rgaRequest(id: ID): RGARequest
  rgaReturnReasons(activeOnly: Boolean = true): [RGAReturnReason!]!
  rawMaterial(id: ID!): RawMaterial
  allRawMaterials(filter: RawMaterialFilter): [RawMaterial!]!
  receivingLocation(id: ID!): ReceivingLocation
  repos(input: ReposInput): [Repo!]
  role(id: ID!): Role
  roles: [Role!]!
  rule(id: ID!): Rule
  rules(filter: RuleFilter): [Rule!]!
  ruleByKey(key: String!): Rule
  ruleTag(id: ID!): RuleTag
  ruleTags: [RuleTag!]!
  salesTeams: [SalesTeam!]!

  """Finds a service by its id."""
  service(id: ID): Service
  shipment(id: ID!): Shipment
  shipments(ids: [ID!]!): [Shipment!]!
  shipmentBatch(id: ID!): ShipmentBatch
  shipmentBatchFromPackage(id: ID!): ShipmentBatch
  shipmentBatches(filter: ShipmentBatchFilterInput): [ShipmentBatch!]!
  shippingMethod(id: ID!): ShippingMethod
  shippingMethods(filter: ShippingMethodFilter): [ShippingMethod!]!
  subAssembly(id: ID!): SubAssembly
  subAssemblies: [SubAssembly!]!
  suggestedGroup(id: ID!): SuggestedGroup
  suggestedGroups(filter: SuggestedGroupFilter): [SuggestedGroup!]!
  tag(id: ID!): Tag
  tags(input: TagsInput!): [Tag!]
  allTags: [Tag!]!
  transaction(id: ID!): DealTransaction
  unitOfMeasure(id: ID!): UnitOfMeasure
  unitOfMeasures(filter: UnitOfMeasureFilter): [UnitOfMeasure!]!
  me: User
  user(
    id: ID!

    """Allows to filter if trashed elements should be fetched."""
    trashed: Trashed
  ): User
  users(filter: UserFilter): [User!]!
  vendor(id: ID): Vendor
  allVendors(filter: VendorFilter): [Vendor!]!
  vendorPart(id: ID): VendorPart
  vrdDelivery(id: ID!): VrdDelivery
  customerDeal(id: ID!, key: String!): Deal
  customerOrder(orderNumber: String!, key: String!): Order

  """
  Get the 'order status' url for a specified order, or send an email if no number is provided.
  """
  customerGetOrderStatusUrl(orderNumber: String, email: String!): String
  rgaCustomerOrders(
    """
    Base 64 encoded customer email - validated and link created using signature generation.
    """
    e: String!
    signature: String!
    expires: Int!
  ): [Order!]!
  rgaOrder(id: ID!, expires: Int!, signature: String!): Order
  deliveryWindow(input: DeliveryWindowInput!): DeliveryWindow
  log(fileName: String!): [Log]
  logs: LogIndex
  logFiles: [String!]
  orderSearch(input: OrderSearchInput!): [Order!]
  queueMonitor(filter: QueueMonitorFilter): [Monitor!]!
  queueMonitorFrequency: [QueueMonitorFrequency!]
  queueSize: Int!
  getRateQuotes(input: GetRateQuoteInput!): [RateQuote!]!
  getShipmentRateQuotes(input: GetShipmentRateQuoteInput!): [RateQuote!]!

  """
  Returns an ESTIMATE of the freight cost for an order. Dims are not provided, so it will not be 100% accurate.
  """
  getOrderFreightQuote(input: GetOrderFreightQuoteInput!): FreightQuote!
  shippingCalculator(input: ShippingCalculatorInput!): ShippingCalculator!
  woodProductionReport(product_type_group_ids: [String!]!, wood_final_date_from: Date, wood_final_date_to: Date): [WoodStationWorkInstruction!]
  woodProductionReportInProcessCnc(wood_production_date_from: Date, wood_production_date_to: Date): [WoodStationWorkInstructionInProcessCnc!]
  woodProductionReportInProcessMoulder(wood_final_date_from: Date, wood_final_date_to: Date): [WoodStationWorkInstructionInProcessMoulder!]
  woodProductionReportInProcessTread(wood_final_date_from: Date, wood_final_date_to: Date): [WoodStationWorkInstructionInProcessTread!]
  woodProductionReportReadyToPrep: [ReadyToPrep!]
  woodProductionReportReadyToStain: [ReadyToStain!]
  woodProductionReportReadyToPrime: [ReadyToPrime!]
  woodProductionReportReadyToClear: [ReadyToClear!]
  woodProductionReportPaintTouchUp: [PaintTouchUp!]
  woodProductionReportReadyToFinalTread: [ReadyToFinalTread!]
  woodProductionReportOrderItems(order_number: ID!, product_type_group_ids: [ID!]!): [OrderItemsReport!]!
  woodProductionReportPrintLabels(order_line_items_id: ID!, product_type_group_ids: [ID!]!, production_item_steps_column: ProductionItemStepColumn!): [PrintLabelsReport!]
  woodProductionReportItemsOnOrderToFinish(order_number: ID!, production_item_steps_column: ProductionItemStepColumn!): [OrderItemsReport!]!
  woodProductionReportItemsOnOrderToFinishLabels(order_line_items_id: ID!, production_item_steps_column: ProductionItemStepColumn!): [PrintLabelsReport!]
  woodProductionReportSamples(wood_final_date_from: Date, wood_final_date_to: Date): [WoodStationSamplesInstruction!]
  appLogs(
    input: AppLogsInput

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): AppLogPaginator
  attributes(
    filter: AttributeFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): AttributePaginator
  bundleGroups(
    filter: BundleGroupFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): BundleGroupPaginator
  companies(
    filter: CompanyFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): CompanyPaginator
  contacts(
    filter: ContactFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): ContactPaginator
  costAccounts(
    filter: CostAccountFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): CostAccountPaginator
  deals(
    filter: DealSearchFilter
    orderBy: [OrderByClause!]

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): DealPaginator
  departments(
    filter: DepartmentFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): DepartmentPaginator
  finishOptions(
    filter: FinishOptionFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): FinishOptionPaginator
  locations(
    filter: LocationFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): LocationPaginator
  manufacturingAttributes(
    filter: ManufacturingAttributeSearchFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): ManufacturingAttributePaginator
  lineItemsPaginated(
    filter: OrderLineItemFilterInput
    query: OrderLineItemsQueryInput

    """Limits number of fetched items."""
    first: Int!

    """The offset from which items are returned."""
    page: Int
  ): OrderLineItemPaginator
  packagesPaginated(
    filter: PackageFilter

    """Limits number of fetched items."""
    first: Int = 50

    """The offset from which items are returned."""
    page: Int
  ): PackagePaginator
  packingBays(
    filter: PackingBayFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): PackingBayPaginator
  products(
    filter: ProductFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): ProductPaginator
  productionItemsPaginated(
    filter: ProductionItemFilterInput
    query: ProductionItemQueryInput

    """Limits number of fetched items."""
    first: Int!

    """The offset from which items are returned."""
    page: Int
  ): ProductionItemPaginator
  purchaseOrders(
    filter: PurchaseOrderFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): PurchaseOrderPaginator
  purchasingParts(
    filter: PurchasingPartFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): PurchasingPartPaginator
  purchasingPartRequests(
    filter: PurchasingPartRequestFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): PurchasingPartRequestPaginator
  rawMaterials(
    filter: RawMaterialFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): RawMaterialPaginator
  receivingLocations(
    filter: ReceivingLocationFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): ReceivingLocationPaginator
  userSearch(
    filter: UserFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): UserPaginator
  vendors(
    filter: VendorFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): VendorPaginator
  vendorParts(
    filter: VendorPartFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): VendorPartPaginator
  vrdDeliveries(
    filter: VrdDeliveriesFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): VrdDeliveryPaginator
  orderSearchPaginated(
    input: OrderSearchInput!

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): OrderPaginator

  """
  Outputs a report of the production activity for the requested fields / items.
  """
  productionActivityReport(
    filter: ProductionActivityReportInput!

    """Limits number of fetched items."""
    first: Int = 500

    """The offset from which items are returned."""
    page: Int
  ): ProductionActivityReportPaginator

  """
  Outputs a report of the production scheduling for the requested fields / items.
  """
  productionScheduleReport(
    filter: ProductionScheduleReportInput!

    """Limits number of fetched items."""
    first: Int = 500

    """The offset from which items are returned."""
    page: Int
  ): ProductionScheduleReportPaginator
  queueMonitorPaginated(
    filter: QueueMonitorFilter

    """Limits number of fetched items."""
    first: Int = 20

    """The offset from which items are returned."""
    page: Int
  ): MonitorPaginator
}

enum QueryOrdersWhereColumn {
  DUE_DATE
  METAL_PRODUCTION_DATE
  WOOD_PRODUCTION_DATE
  GLASS_PRODUCTION_DATE
  FLIGHT_PRODUCTION_DATE
}

"""
Dynamic WHERE conditions for the `where` argument on the query `orders`.
"""
input QueryOrdersWhereWhereConditions {
  """The column that is used for the condition."""
  column: QueryOrdersWhereColumn

  """The operator that is used for the condition."""
  operator: SQLOperator = EQ

  """The value that is used for the condition."""
  value: Mixed

  """A set of conditions that requires all conditions to match."""
  AND: [QueryOrdersWhereWhereConditions!]

  """A set of conditions that requires at least one condition to match."""
  OR: [QueryOrdersWhereWhereConditions!]

  """
  Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  """
  HAS: QueryOrdersWhereWhereConditionsRelation
}

"""
Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `orders`.
"""
input QueryOrdersWhereWhereConditionsRelation {
  """The relation that is checked."""
  relation: String!

  """The comparison operator to test against the amount."""
  operator: SQLOperator = GTE

  """The amount to test."""
  amount: Int = 1

  """Additional condition logic."""
  condition: QueryOrdersWhereWhereConditions
}

input QueueMonitorFilter {
  ordered: Boolean
  lastHour: Boolean
  today: Boolean
  failed: Boolean
  succeeded: Boolean
  status: QueueMonitorInputEnum
}

type QueueMonitorFrequency {
  time: DateTime!
  failed: Int!
  succeeded: Int!
  running: Int!
  stale: Int!
}

enum QueueMonitorInputEnum {
  RUNNING
  SUCCEEDED
  FAILED
  STALE
}

type RGAFormRequestItem {
  id: ID!
  type: RelationType!
  quantity: Int!
}

input RGAFormRequestItemInput {
  id: ID!
  type: RelationType!
  quantity: Int!
}

type RGARequest {
  id: ID!
  order_id: ID!
  number_of_packages: Int!
  rga_return_reason_id: ID!
  details: String!
  items: [RGAFormRequestItem!]!
  returnItems: [ReturnItem!]!
  reason: RGAReturnReason!
  order: Order!
  packableItems: [PackableItem!]!
  files: [File!]!
  labelFiles: [File!]!
}

type RGAReturnReason {
  id: ID!
  name: String!
  active: Boolean!
  sort: Int!
}

type RateQuote {
  name: String!
  friendlyName: String!
  price: Float!
  markup_price: Float!
  markup_rate: Float!
  carrier: ShippingCarrier!
  shippingMethodId: ID
  shippingMethod: ShippingMethod
  DistributionCenter: DistributionCenter
  ShippingMethodEnum: ShippingMethodEnum
  ShippingMethod: ShippingMethod
}

input RateQuoteAddress {
  first_name: String
  last_name: String
  company: String
  address_1: String
  address_2: String
  address_3: String
  city: String
  state: String
  zip: String!
  country: RateQuoteCountry = US
}

enum RateQuoteCountry {
  US
  CA
}

input RateQuotePackage {
  length: Float
  width: Float
  height: Float
  shipping_class: String!
  weight: Float!
  quantity: Int = 1
}

type RawMaterial {
  id: ID!
  name: String!
  cost: Float!
  active: Boolean!
  created_at: DateTime
  updated_at: DateTime
}

input RawMaterialFilter {
  ids: [ID!]
  name: String
  active: Boolean
}

"""A paginated list of RawMaterial items."""
type RawMaterialPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of RawMaterial items."""
  data: [RawMaterial!]!
}

type ReadyToClear {
  order_number: ID!
  due_date: Date!
  wood_final_date: Date
  finish_options_name: String!
  exceptions: WoodExceptions!
}

type ReadyToFinalTread {
  order_number: ID!
  order_line_items_quantity: Int!
  production_item_steps_final_wood: Int!
  wood_final_date: Date
  exception_production_item_ids: [ID!]!
  exceptions: WoodExceptions!
}

type ReadyToPrep {
  order_number: ID!
  order_line_items_quantity: Int!
  production_item_steps_final_wood: Int!
  production_item_steps_finish_prep: Int!
  wood_final_date: Date!
  exceptions: WoodExceptions!
}

type ReadyToPrime {
  order_number: ID!
  order_line_items_quantity: Int!
  production_item_steps_final_wood: Int!
  production_item_steps_finish_complete: Int!
  wood_final_date: Date
  finish_options_name: String!
  exceptions: WoodExceptions!
}

type ReadyToStain {
  order_number: ID!
  order_line_items_quantity: Int!
  production_item_steps_finish_prep: Int!
  production_item_steps_finish_stain: Int!
  finish_options_name: String!
  wood_final_date: Date!
  exceptions: WoodExceptions!
}

type ReceivingLocation {
  id: ID!
  name: String!
  address_id: ID
  address: Address
  addresses: [Address!]!
}

input ReceivingLocationFilter {
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of ReceivingLocation items."""
type ReceivingLocationPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of ReceivingLocation items."""
  data: [ReceivingLocation!]!
}

input RefreshTokenInput {
  refresh_token: String
}

type RefreshTokenPayload {
  access_token: String!
  refresh_token: String!
  expires_in: Int!
  token_type: String!
}

input RegisterInput {
  name: String!
  email: String!
  password: String!
  password_confirmation: String!
}

type RegisterResponse {
  tokens: AuthPayload
  status: RegisterStatuses!
}

enum RegisterStatuses {
  MUST_VERIFY_EMAIL
  SUCCESS
}

enum RelationType {
  ORDER
  DEAL
  CONTACT
  LINE_ITEM
  FILE
  NOTE
  VENDOR
  ENGINEERING_TASK
  PRODUCT_GROUP
  PRODUCT_TYPE
  PRODUCT_FAMILY
  PRODUCT
  RECEIVING_LOCATION
  PURCHASE_ORDER
  VENDOR_PART
  USER
  COMPANY
  SHIPMENT
  PRODUCTION_ITEM
  PACKAGE
  ADDRESS
  SETTING
  RGA_REQUEST
  SHIPMENT_BATCH
  PRODUCTION_ITEM_STEP
  APP_SETTING
  PERMISSION
  SHIPPING_METHOD
  LOCATION
}

type RemakeProcess {
  id: ID!
  name: String!
}

type RemakeReason {
  id: ID!
  name: String!
  remake_process_id: ID!
}

type RemakeSubReason {
  id: ID!
  name: String!
  remake_reason_id: ID!
}

input RemovePackageFromShipmentBatchInput {
  batch_id: ID!
  package_id: ID!
}

type Repo {
  id: ID!
  repoType: RepoType!
  payload: String!
  order_number: String
  price: Float
  created_at: DateTime!
  updated_at: DateTime
}

type RepoType {
  id: ID!
  name: String!
  created_at: DateTime!
  updated_at: DateTime
  repos: [Repo!]!
}

enum RepoTypes {
  VictorEstimate
}

input RepoUpsertFromOrderNumber {
  order_number: String!
  repoType: RepoTypes!
  payload: JSON
  price: Float
}

input ReposInput {
  repoType: RepoTypes
  order_number: String
}

enum RequestedPartStatus {
  Open
  Approved
  Denied
}

enum RequestedPartType {
  OneTimePart
  PurchasingPart
}

type ReturnItem {
  id: ID!
  type: RelationType!
  quantity: Int!
  name: String!
  isReturnable: Boolean!
  returnPrices(
    """
    Whether or not we should check recent orders [for free / zero-cost items] when performing this calculation.
    """
    checkRecent: Boolean = true
  ): [Float!]

  """
  Returns the price for the quantity specified on this return item (if a user has already requested a quantity).
  """
  priceForQuantity: Float
}

enum RodType {
  NON_ROD
  ROD
  ROD_INCLUDE
}

type Role {
  id: ID!
  name: String!
  created_at: DateTime
  updated_at: DateTime
  permissions: [Permission!]!
}

type Rule {
  id: ID!
  key: String
  title: String!
  description: String!
  justification: String
  created_at: DateTime
  updated_at: DateTime
  tags: [RuleTag!]!
}

input RuleCreateInput {
  key: String
  title: String!
  description: String!
  justification: String
  tags: RuleTagRelationInput
}

input RuleFilter {
  keys: [String!]
}

type RuleTag {
  id: ID!
  name: String!
}

input RuleTagCreateInput {
  name: String!
}

input RuleTagRelationInput {
  create: [RuleCreateInput!]
  connect: [ID!]
  update: [RuleUpdateInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  delete: [ID!]
  disconnect: [ID!]
}

input RuleTagUpdateInput {
  id: ID!
  name: String!
}

input RuleUpdateInput {
  id: ID!
  key: String
  title: String
  description: String
  justification: String
  tags: RuleTagRelationInput
}

enum SQLOperator {
  EQ
  NEQ
  GT
  GTE
  LT
  LTE
  LIKE
  NOT_LIKE
  IN
  NOT_IN
  BETWEEN
  NOT_BETWEEN
  IS_NULL
  IS_NOT_NULL
}

type SalesTeam {
  id: ID!
  name: String!
  users: [User]!
  orders: [Order]!
}

input SchemaDumpInput {
  """How many minutes the link will be valid."""
  minutes: Int
}

input SearchInput {
  id: String!
}

type SearchResults {
  Order: Order
}

type Service {
  id: ID!
  order_line_item_id: ID!

  """The order line item name."""
  name: String
  quantity: Int!

  """A quanitity based on the completed_services table."""
  completedQuantity: Int!
  created_at: DateTime
  updated_at: DateTime

  """Returns true when completedQuantity = quantity."""
  isComplete: Boolean!

  """Returns the created_at value when a service is started."""
  started: DateTime

  """Returns the updated_at value when a service is completed."""
  completed: DateTime
}

type Shipment {
  id: ID!
  order_id: ID!
  user_id: ID!
  shipped_by_id: ID
  shippedBy: User
  shipping_method: ID
  shippingMethod: ShippingMethod
  tracking_code: String
  cost: Float
  shipment_date: DateTime
  shipment_batch_id: ID
  customer_signature_file_id: ID
  shipmentBatch: ShipmentBatch

  """Boolean flag for whether or not this was a manually shipped order."""
  manual: Boolean!
  created_at: DateTime!
  updated_at: DateTime!
  order: Order!
  user: User!
  packages: [Package!]!
  files: [File!]!
  packingListPDFLink: String!
  labelFiles: [File!]!
  labelFilesCount: Int!
  bolFiles: [File!]!
  bolFilesCount: Int!

  """
  Returns the File object for the customer signature file associated with this shipment.
  """
  customerSignature: File

  """
  Returns a boolean value for whether or not a customer signature file has been uploaded for this shipment.
  """
  hasSignature: Boolean!

  """Whether or not this shipment has shipped."""
  isShipped: Boolean!

  """
  Performs validation on the shipment and packages. Returns whether or not the shipment is valid.
  """
  isValidToShip(
    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): Boolean!

  """
  Performs validation on the shipment and packages. Returns an array of strings / validation errors.
  """
  isValidToShipMessages(
    """Whether or not we should bail on the first found error."""
    bailEarly: Boolean = false

    """
    Whether or not we should check valid shipping requirements against a privileged user (a user who has the role /
    permission to bypass certain validation checks).
    """
    emulateUser: IsValidToShipUserType = DEFAULT
  ): [ValidationMessage!]!

  """Checks OD1 to see if this shipment is available to be voided."""
  isValidToVoid: Boolean

  """
  Will attempt to get the tracking URL for this shipment by looking at provider & tracking code.
  """
  trackingUrl: String

  """Get the link for a PDF for this item."""
  pdfLink(type: ShipmentPDFTypes!): String!
  getPackageTypes: String!
  meta: String
  dropship: Boolean
  audits: [Audit!]!
}

type ShipmentBatch {
  id: ID!
  shipping_method_id: ID!
  shippingMethod: ShippingMethod!
  vrd_import_location_id: ID
  vrdImportLocation: VRDLocation
  user_id: ID!
  user: User!
  packages: [Package!]!
  shipments: [Shipment!]!
  manifest_link: String
  all_shipped: Boolean!
  started_processing_at: DateTime
  finished_processing_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

input ShipmentBatchFilterInput {
  ids: [ID]
  orderBy: [OrderByClause!]
  date_from: Date
  date_to: Date
}

input ShipmentBatchPackageRelation {
  create: [PackageCreateInput!]
  update: [PackageUpdateInput!]
  connect: [ID!]
  delete: [ID!]
}

input ShipmentBatchShipmentRelation {
  create: [ShipmentCreateInput!]
  update: [ShipmentUpdateInput!]
  connect: [ID!]
  delete: [ID!]
}

input ShipmentCreateInput {
  order_id: ID!
  user_id: ID
  shipping_method: ID
  tracking_code: String
  cost: Float
  shipment_date: DateTime
  created_at: DateTime
  updated_at: DateTime
  packages: ShipmentPackageRelation
}

input ShipmentFilter {
  orderBy: [OrderByClause]
  isShipped: Boolean
}

input ShipmentOptions {
  destination_liftgate: Boolean
  residential: Boolean
  saturday_delivery: Boolean
  special_instructions: String
  am_delivery: Boolean
  evening_delivery: Boolean
}

enum ShipmentPDFTypes {
  PACKING_LIST
}

input ShipmentPackageRelation {
  create: [PackageCreateInput!]
  update: [PackageUpdateInput!]
  connect: [ID!]
  delete: [ID!]
}

input ShipmentProcessorOptions {
  """
  Whether or not we should send an email to the customer regarding the shipping information.
  """
  sendEmail: Boolean = true
}

type ShipmentResponse {
  shipment: Shipment!
  success: Boolean!
  errors: [String!]!
  warnings: [String!]!
}

input ShipmentUpdateInput {
  id: ID!
  order_id: ID
  user_id: ID
  shipping_method: ID
  tracking_code: String
  cost: Float
  shipment_date: DateTime
  created_at: DateTime
  updated_at: DateTime
  packages: ShipmentPackageRelation
}

type ShippingCalculator {
  Order: Order!
  lead_days: Int!
  vrd_available: Boolean!
  has_wood: Boolean!
  has_metal: Boolean!
  has_glass: Boolean!
  has_flight: Boolean!
  release_date: DateTime!
  due_date: DateTime!
  ShippingMethod: ShippingMethod
  truck_leaves: DateTime
  delivery_window_from: DateTime
  delivery_window_to: DateTime
  warehouse_name: String
  VrdSection: VrdSection
}

input ShippingCalculatorInput {
  order_number: ID!
  release_date: Date
  override_wood: Boolean
  override_metal: Boolean
  override_glass: Boolean
  override_flight: Boolean
}

enum ShippingCarrier {
  FEDEX
  UPS
  USPS
  RLC
  STAMPS
  VRD
  LOCAL
}

type ShippingMethod {
  id: ID!
  name: String!
  carrier: ShippingCarrier
  transport_class: TransportClass!
  next_day_air: Boolean!
  same_day: Boolean!
  active: Boolean!
}

enum ShippingMethodEnum {
  our_truck
  customer_pickup
  ups_ground
  drop_ship
  us_mail
  yrc
  ups_next_day_air
  ups_second_day_air
  ups_three_day_select
  fedex_pri_overnight
  fedex_std_overnight
  fedex_ground
  ceva
  fedex_freight_economy
  inventory_cleanup
  ups_freight
  rl
  fedex_freight_priority
  rl_guaranteed
  rl_guaranteed_by_noon
  rl_expedited
  ups_next_day_air_saver
  parcel_home_delivery
  parcel_express_saver_three_day
  parcel_express_two_day
  parcel_priority_overnight
  parcel_standard
  build_to_stock
  dedicated_truck
  ups_mail_priority
  estes
  ats
  vr_van
  vrd
  plant_four
  vrd_punta_gorda
  vrd_pennsylvania
  abf
  vrd_goshen
  vrd_northeast
  vrd_south
  vrd_springfield
  vrd_edison
  dedicated_truck_vri
  vrd_hollister
  rl_hollister
  ups_ground_hollister
  vrd_winchester_va
  ltl_vrd_springfiled_ma
  vrd_otr
  dhx_hollister
}

input ShippingMethodFilter {
  ids: [ID!]
}

type ShippingMethodSetting {
  appSetting: AppSetting!
  selected: ShippingMethod
  options: [ShippingMethod!]!
}

enum ShippingProviderOption {
  LIFTGATE
  RESIDENTIAL
  SPECIAL_INSTRUCTIONS
  SATURDAY_DELIVERY
  AM_DELIVERY
  EVENING_DELIVERY
}

"""Information about pagination using a simple paginator."""
type SimplePaginatorInfo {
  """Number of items in the current page."""
  count: Int!

  """Index of the current page."""
  currentPage: Int!

  """Index of the first item in the current page."""
  firstItem: Int

  """Index of the last item in the current page."""
  lastItem: Int

  """Number of items per page."""
  perPage: Int!

  """Are there more pages after this one?"""
  hasMorePages: Boolean!
}

input SocialLoginInput {
  provider: SocialLoginProvider!
  token: String!
}

enum SocialLoginProvider {
  google
}

"""Directions for ordering a list of records."""
enum SortOrder {
  """Sort records in ascending order."""
  ASC

  """Sort records in descending order."""
  DESC
}

input SpecialOrderItemsInput {
  """One or more order numbers to filter by."""
  order_number: String

  """A date we should use as a >= comparison."""
  releasedAfterDate: Date

  """Filter by specific product type group IDs. At least one is required."""
  productProductionType: ProductionTypeEnum!

  """
  Filter items that have engineering required and complete/not yet complete
  """
  engineeringComplete: Boolean
}

input SplitOrderInput {
  order_id: ID!
  items: [ID!]
  groups: [ID!]
}

enum StringerType {
  NON_STRINGER
  STRINGER
  STRINGER_INCLUDE
}

type SubAssembly {
  id: ID!
  name: String!
  order_line_item_id: ID
  production_item_id: ID
  parent_id: ID
  quantity: Int
  data: String
  instructions: String
  lineItem: OrderLineItem
  productionItem: ProductionItem
  parent: SubAssembly
  children: [SubAssembly!]!
}

input SubAssemblyBulkDeleteFilter {
  ids: [ID!]
}

type SuggestedGroup {
  id: ID!
  name: String!
  products: [Product]
  suggestedGroupProducts: [Product]
  created_at: DateTime
  updated_at: DateTime
}

input SuggestedGroupFilter {
  ids: [ID]
  name: String
  productName: String
  suggestedProductName: String
}

input SuggestedGroupProductRelation {
  connect: [ID!]
  disconnect: [ID!]
  update: UpdateProductInput
}

type SyncOrderResponse {
  orderNumber: String
}

type Tag {
  id: ID!
  name: String!
  slug: String!
  type: ID
  order_column: ID
  created_at: DateTime
  updated_at: DateTime
  files: [File!]
  taggables: [Taggable!]!
}

input TagFilesInput {
  tagIds: [ID!]!
  fileIds: [ID!]!
}

input TagRelation {
  connect: [ID!]
  disconnect: [ID!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
}

type Taggable {
  id: ID
  taggable: TaggableModelType!
}

union TaggableModelType = File | Note

enum Tags {
  internal
  engineering
  customer
  fig
  gig
  tig
  flight_map
  document_to_print
  final_install_instructions
  measurement_form
  contract
}

input TagsInput {
  ids: [ID]
  name: String
  slug: String
}

input TransactionCreateInput {
  deal_id: ID!
  transaction_date: DateTime
  charge_type: ChargeType!
  amount: Float
  received: Boolean
  meta: JSON
}

input TransactionCreditCard {
  encrypted_number: String!
  expiration_year: String!
  expiration_month: String!
}

input TransactionUpdateInput {
  id: ID!
  deal_id: ID
  transaction_date: DateTime
  charge_type: ChargeType
  amount: Float
  received: Boolean
  meta: JSON
}

enum TransportClass {
  GROUND
  FREIGHT
  ABNORMAL
}

"""
Specify if you want to include or exclude trashed results from a query.
"""
enum Trashed {
  """Only return trashed results."""
  ONLY

  """Return both trashed and non-trashed results."""
  WITH

  """Only return non-trashed results."""
  WITHOUT
}

enum UPSShipmentServiceCode {
  NEXT_DAY_AIR
  SECOND_DAY_AIR
  GROUND
  EXPRESS
  EXPEDITED
  UPS_STANDARD
  THREE_DAY_SELECT
  NEXT_DAY_AIR_SAVER
  UPS_NEXT_DAY_AIR_EARLY
  UPS_WORLDWIDE_ECONOMY_DDU
  EXPRESS_PLUS
  SECOND_DAY_AIR_AM
  UPS_SAVER
  FIRST_CLASS_MAIL
  PRIORITY_MAIL
  EXPEDITED_MAIL_INNOVATIONS
  PRIORITY_MAIL_INNOVATIONS
  ECONOMY_MAIL_INNOVATIONS
  MAIL_INNOVATIONS_RETURNS
  UPS_ACCESS_POINT_ECONOMY
  UPS_WORLDWIDE_EXPRESS_FREIGHT_MIDDAY
  UPS_WORLDWIDE_ECONOMY_DDP
  UPS_EXPRESS_TWELVE_O_CLOCK
  UPS_TODAY_STANDARD
  UPS_TODAY_DEDICATED_COURIER
  UPS_TODAY_INTERCITY
  UPS_TODAY_EXPRESS
  UPS_TODAY_EXPRESS_SAVER
  UPS_WORLDWIDE_EXPRESS_FREIGHT
}

type UnitOfMeasure {
  id: ID!
  name: String!
  symbol: String!
  active: Boolean!
  created_at: DateTime
  updated_at: DateTime
}

input UnitOfMeasureFilter {
  ids: [ID]
  name: String
  symbol: String
  active: Boolean
}

enum UnitOfMeasures {
  bf
  lf
  pc
  sf
  oz
  gal
  g
}

input UnpackMetalHandrailInput {
  production_item_id: ID!
  package_id: ID!
  quantity: Int!
}

input UpdateAppSettingInput {
  id: ID!
  key: String
  value: JSON
  description: String
}

input UpdateAttributeInput {
  id: ID!
  name: String
  filterable: Boolean
  applies_to_variations: Boolean
  options: UpdateAttributeOptionsRelation
}

input UpdateAttributeOptionInput {
  id: ID!
  name: String
}

input UpdateAttributeOptionsRelation {
  create: [CreateAttributeOptionInput!]!
}

input UpdateBuildingInput {
  id: ID!
  name: String!
  color: String!
}

input UpdateBundleGroupInput {
  id: ID!
  name: String
  products: BundleGroupProductsRelation
}

input UpdateBundleInput {
  id: ID!
  product_id: ID
  bundle_product_id: ID
  bundle_group_id: ID
  bundle_type_id: ID!
  quantity: Int!
}

input UpdateBundleRuleInput {
  id: ID!
  product_id: ID
  options: BundleRuleOptionsRelation
  ruleProducts: BundleRuleProductsRelation
}

input UpdateBundleRuleProductInput {
  id: ID
  product_id: ID
  bundle_rule_id: ID
  bundle_type_id: ID
  bundle_product_id: ID
}

input UpdateCostAccountInput {
  id: ID!
  name: String!
}

input UpdateDepartmentInput {
  id: ID!
  name: String
}

input UpdateDimensionInput {
  product_id: ID!
  length: Float
  width: Float
  height: Float
  unit_weight: Float
}

input UpdateEngineeringTaskProductsRelation {
  create: [EngineeringTaskCreateInput!]
  connect: [ID!]
  update: [EngineeringTaskUpdateInput!]
  upsert: [EngineeringTaskUpdateInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  delete: [ID!]
  disconnect: [ID!]
}

input UpdateEpcHasMany {
  create: [EpcCreateInput!]
}

input UpdateFinishGroupInput {
  id: ID!
  name: String
  active: Boolean
  finishOptions: FinishGroupFinishOptionRelation
}

input UpdateFinishOptionInput {
  id: ID!
  name: String
  description: String
  victor_name: String
  finish_multiplier: Float
  is_prime: Boolean
  is_stain: Boolean
  is_clear: Boolean
  is_outsourced: Boolean
  block_order_release: Boolean
  archived: Boolean
  attributeOptions: FinishOptionAttributeOptionRelation
  finishGroups: FinishOptionFinishGroupRelation
}

input UpdateGlobalSaleInput {
  id: ID!
  start_date: DateTime
  end_date: DateTime
  sale_percent: Float
  productGroups: GlobalSaleRelation
  productTypes: GlobalSaleRelation
  productFamilies: GlobalSaleRelation
  products: GlobalSaleRelation
}

input UpdateInventoryInput {
  product_id: ID!
  bin_qty: Int
  bin_count: Int
  show_barcode: Boolean
  inventory_type: InventoryType
  is_hpc: Boolean
  is_prepackaged: Boolean
  kanban_bin_location: String
  pick_to_light_device_id: String
}

input UpdateItemExceptionInput {
  id: ID!
  reason_id: ID
  quantity: Int
  additional_notes: String
}

input UpdateLocationInput {
  id: ID!
  name: String
  parent_id: ID
}

input UpdateManufacturingAttribute {
  id: ID!
  key: String
  datatype: String
  level: String
  options: ManufacturingAttributeOptionRelation
}

input UpdateManufacturingAttributeOption {
  id: ID!
  value: String
  manufacturing_attribute_id: ID!
}

input UpdateManufacturingInput {
  product_id: ID!
  process_time: Int
  buffer_time: Int
  cnc_program: String
  production_data: JSON
}

input UpdateMaterialInput {
  id: ID!
  name: String!
  product_name: String
  material_type_id: ID!
  finish_group_id: ID
  active: Boolean
  MaterialSizes: MaterialSizeRelation
}

input UpdateMaterialLengthInput {
  id: ID!
  name: String
  active: Boolean
  material_type_id: ID
  unit_of_measure_id: ID
}

input UpdateMaterialSizeInput {
  id: ID!
  name: String
  material_type_id: ID
  sort: Int
  active: Boolean
}

input UpdateMaterialTypeInput {
  id: ID!
  name: String
  active: Boolean
}

input UpdateNoteInput {
  id: ID!
  content: String
  tags: NoteTagRelation
  user_id: ID
}

input UpdateOD1ProductTypeGroupInput {
  id: ID!
  name: String
  od1_parent_group_id: ID
  active: Boolean
}

input UpdateOrderGroupInput {
  id: ID!
  order_id: ID!
  name: String
  sort: Int
}

input UpdateOrderLineItemGroupInput {
  id: ID!
  name: String
  sort: Int
  items: OrderLineItemGroupItemsRelation
}

input UpdateOrderProductTypeGroupScheduleByFilterInput {
  order_id: ID!
  od1_product_type_group_id: ID!
  production_date: Date!
}

input UpdateOrderProductTypeGroupScheduleInput {
  id: ID!
  order_id: ID
  od1_product_type_group_id: ID
  production_date: Date
}

input UpdateOrderRemake {
  id: ID!
  remake_notes: String!
  order: OrderRemakeOrderRelationInput
  reasons: OrderRemakeReasonRelationInput
  lineItems: OrderRemakeLineItemRelationInput
}

input UpdateOrderRemakeReason {
  id: String!
  order_remake_id: ID
  remake_process_id: ID
  remake_reason_id: ID
  remake_sub_reason_id: ID
}

input UpdatePackingBayInput {
  id: ID!
  name: String!
}

input UpdatePermissionInput {
  id: ID!
  name: String
  group: String
  description: String
}

input UpdatePieceInput {
  id: ID!
  product_id: ID!
  piece_product_id: ID!
  quantity: Int!
}

input UpdatePiecePackInput {
  id: ID!
  product_id: ID!
  piece_pack_product_id: ID!
  quantity: Int!
}

input UpdatePostBracketInput {
  id: ID!
  name: String
  active: Boolean
}

input UpdatePostTopStyleInput {
  id: ID!
  name: String
  active: Boolean
  post_bracket_id: ID
  post_top_type_id: ID
  material_id: ID
}

input UpdatePostTopTypeInput {
  id: ID!
  name: String
  active: Boolean
}

input UpdatePricingTierInput {
  id: ID!
  tier_weight: Float
  tier_number: Int
  options: PricingTierOptionsRelation
}

input UpdateProductCustomization {
  id: ID!
  name: String
  additional_price: Float
  additional_labor_cost: Float
  archived: Boolean
  accounting_type_id: ID
  od1ProductTypes: ProductCustomizationOd1ProductTypeRelation
}

input UpdateProductFamilyInput {
  id: ID!
  name: String
  process_time: Int
  buffer_time: Int
  customization_prefix: String
  dropship: Boolean
  customizable: Boolean
  discountable: Boolean
  deleted_at: DateTime
  product_type_id: ID
  attributes: ProductFamilyAttributeRelation
  manufacturingAttributes: ProductFamilyManufacturingAttributeRelation
  globalSales: ProductFamilyAddressRelation
  features: ProductFeatureRelation
}

input UpdateProductFeature {
  id: ID!
  name: String
  name_suffix: String
  description: String
  additional_price: Float
  additional_labor_cost: Float
  post_cnc_program_suffix: String
  od1_accounting_type_id: String
  od1ProductTypes: ProductFeatureOd1ProductTypeRelation
  name_suffix_price_sync: String
  active: Boolean
}

input UpdateProductGroupInput {
  id: ID!
  name: String
  process_time: Int
  buffer_time: Int
  engineering_lead_time: Int
  attributes: ProductGroupAttributeRelation
}

input UpdateProductInput {
  id: ID!
  name: String
  customer_product_name: String
  customer_product_description: String
  customer_notes: String
  description: String
  price: Float
  sale_price_percent: Float
  purchase_price: Float
  purchase_price_included_products: Float
  labor_cost: Float
  pre_finish_cost: Float
  finish_price: Float
  instructions: String
  is_present_on_stairsupplies: String
  is_present_on_viewrail: String
  viewrail_image_url: String
  viewrail_slug: String
  stairsupplies_image_url: String
  stairsupplies_slug: String
  stairsupplies_website_url: String
  viewrail_website_url: String
  website_image_override_url: String
  children_naming_scheme: String
  website_part_name: String
  postTopStyle: ProductPostTopStyleRelation
  postFootStyle: ProductPostFootStyleRelation
  post_cnc_program: String
  post_angle_required: Boolean
  post_configuration: String
  post_cut_angle: Int
  post_cut_length: Float
  post_distance_from_top_back: Float
  post_distance_from_top_front: Float
  post_distance_from_top_left: Float
  post_distance_from_top_right: Float
  post_has_postside_bracket_back: Boolean
  post_has_postside_bracket_front: Boolean
  post_has_postside_bracket_left: Boolean
  post_has_postside_bracket_right: Boolean
  post_hole_size_back: Float
  post_hole_size_front: Float
  post_hole_size_left: Float
  post_hole_size_right: Float
  post_inventor_configuration: String
  post_inventor_direction: String
  post_number_of_holes_back: Float
  post_number_of_holes_front: Float
  post_number_of_holes_left: Float
  post_number_of_holes_right: Float
  post_routing_instructions: String
  post_system_height: Float
  post_top_to_first_hole_back: Float
  post_top_to_first_hole_front: Float
  post_top_to_first_hole_right: Float
  post_top_to_first_hole_left: Float
  wood_dim_material_id_1: ID
  wood_dim_material_id_2: ID
  wood_dim_material_id_3: ID
  wood_dim_material_id_4: ID
  wood_dim_material_size_id_1: ID
  wood_dim_material_size_id_2: ID
  wood_dim_material_size_id_3: ID
  wood_dim_material_size_id_4: ID
  wood_dim_prc_chop_1: Float
  wood_dim_prc_chop_2: Float
  wood_dim_prc_chop_3: Float
  wood_dim_prc_chop_4: Float
  wood_dim_chop_quantity_1: Float
  wood_dim_chop_quantity_2: Float
  wood_dim_chop_quantity_3: Float
  wood_dim_chop_quantity_4: Float
  wood_dim_rip_width_1: Float
  wood_dim_rip_width_2: Float
  wood_dim_rip_width_3: Float
  wood_dim_rip_width_4: Float
  wood_dim_plane_thickness_1: Float
  wood_dim_plane_thickness_2: Float
  wood_dim_plane_thickness_3: Float
  wood_dim_plane_thickness_4: Float
  wood_dim_glue_type_1: String
  wood_dim_glue_type_2: String
  wood_dim_glue_type_3: String
  wood_dim_glue_type_4: String
  wood_dim_final_width_1: Float
  wood_dim_final_width_2: Float
  wood_dim_final_width_3: Float
  wood_dim_final_width_4: Float
  wood_dim_final_length_1: Float
  wood_dim_final_length_2: Float
  wood_dim_final_length_3: Float
  wood_dim_final_length_4: Float
  wood_dim_final_height_1: Float
  wood_dim_final_height_2: Float
  wood_dim_final_height_3: Float
  wood_dim_final_height_4: Float
  glass_base: Float
  glass_height: Float
  glass_number_of_slots: Float
  glass_number_of_holes: Float
  board_footage: Float
  classification: ProductClassification
  parent_id: ID
  lead_time: Int
  product_family_id: ID
  od1_product_type_id: ID
  material_size_id: ID
  material_id: ID
  is_custom_product: Boolean
  product_status: ProductStatus
  dimension: ProductDimensionRelation
  inventory: ProductInventoryRelation
  attributes: ProductAttributeRelation
  manufacturing: ProductManufacturingRelation
  options: ProductOptionRelation
  manufacturingAttributes: ProductManufacturingAttributeRelation
  productionCharts: ProductProductionChartRelation
  bundles: ProductBundlesRelation
  pieces: ProductPiecesRelation
  piecePacks: ProductPiecePacksRelation
  purchasing_part: PurchasingPartRelation
  archived: Boolean
  stringer_length: Float
  zero_price_when_mandatory: Boolean
  ship_as_freight: Boolean
  auto_convert_to_special_on_import: Boolean
  prevents_order_release: Boolean
  shipping_class: Float
  raw_material_id: ID
  raw_material_qty_per_unit: Int
  finish_option_id: ID
  is_install_kit: Boolean
  is_hpc: Boolean
  handrail_profile: String
  handrail_length: Float
  stock_out: Boolean
  is_haz_mat: Boolean
  unit_weight: Float
  suggestedProducts: ProductSuggestedGroupRelation
  suggestedGroups: ProductSuggestedGroupRelation
}

input UpdateProductProductionChart {
  id: ID!
  product_id: ID
  thickness: Float
  length: Float
  depth: Float
  final_thickness: Float
  final_length: Float
  final_depth: Float
  chop_quantity: Float
  glue_type: String
}

input UpdateProductSuggestedGroupInput {
  product_id: ID
  product_suggestion_id: ID
  suggested_group_id: ID
  quantity: Int
  mandatory: Boolean
}

input UpdateProductTypeInput {
  id: ID!
  name: String
  enumerate: Boolean
  process_time: Int
  buffer_time: Int
  capacity: Int
  product_group_id: ID
  attributes: ProductTypeAttributeRelation
}

input UpdateProductionItemInput {
  id: ID!
  epcs: UpdateEpcHasMany
}

input UpdateProductionSchedulingGroupInput {
  id: ID!
  name: String
  capacity: Int
  label: String
  od1ProductTypeGroupIds: [ID!]
}

input UpdatePurchaseOrderInput {
  id: ID!
  purchase_order_status: PurchaseOrderStatus
  created_by_id: ID
  purchase_order_notes: String
  shipping_cost: Float
  item_tax: Float
  due_date: Date
  received_on: Date
  lineItems: PurchaseOrderLineItemRelation
  addresses: PurchaseOrderAddressRelation
}

input UpdatePurchaseOrderLineItemInput {
  id: ID!
  vendor_part_id: ID
  name: String
  description: String
  vendor_sku: String
  cost_account_id: ID
  department_id: ID

  """quantity: Int"""
  purchase_price: Float
  reorder_quantity: Int
  requested_quantity: Int
  received_quantity: Int
}

input UpdatePurchasingPartInput {
  id: ID!
  name: String
  description: String
  product_id: ID
  vendorParts: VendorPartRelation
}

input UpdatePurchasingPartRequestInput {
  id: ID!
  requested_quantity: Int
  requested_status: RequestedPartStatus
  purchasing_part_id: ID
  description: String
  purchase_price: Float
}

input UpdateRGARequestInput {
  id: ID!
  order_id: ID
  number_of_packages: Int
  rga_return_reason_id: ID
  details: String
  items: [RGAFormRequestItemInput!]!
}

input UpdateRawMaterialInput {
  id: ID!
  name: String
  cost: Float
  active: Boolean
}

input UpdateReceivingLocationInput {
  id: ID!
  name: String
}

input UpdateRoleInput {
  id: ID!
  name: String
  permissions: PermissionRuleRelation
}

input UpdateShipmentBatchInput {
  id: ID!
  shipping_method_id: ID!
  vrd_import_location_id: ID
  shipments: ShipmentBatchShipmentRelation
}

input UpdateShippingMethodInput {
  id: ID!
  name: String!
  carrier: ShippingCarrier
  transport_class: TransportClass!
  next_day_air: Boolean!
  same_day: Boolean!
  active: Boolean!
}

input UpdateSubAssemblyInput {
  id: ID!
  name: String
  order_line_item_id: ID
  production_item_id: ID
  parent_id: ID
  quantity: Int
  data: String
  instructions: String
}

input UpdateSuggestedGroupInput {
  id: ID!
  name: String
  products: SuggestedGroupProductRelation
  suggestedGroupProducts: SuggestedGroupProductRelation
}

input UpdateTagInput {
  id: ID!
  files: TagRelation
  notes: TagRelation
}

input UpdateUnitOfMeasureInput {
  id: ID!
  name: String
  symbol: String
  active: Boolean
}

input UpdateUserInput {
  id: ID!
  username: String
  first_name: String
  last_name: String
  password: String
  email: String
  phone: String
  sales_team_id: ID
  roles: UserRoleRelation
  permissions: UserPermissionRelation
}

input UpdateVendorInput {
  id: ID!
  name: String
  phone: String
  fax: String
  attention: String
  email: String
  terms: String
  purchasing_default_tax: Float
  purchasing_rules: String
  dropship: Boolean
  mfg: Boolean
  parts: VendorPartRelation
}

input UpdateVendorPartInput {
  id: ID!
  vendor_id: ID
  name: String
  description: String
  vendor_sku: String
  notes: String
  cost_account_id: ID
  department_id: ID
  purchase_price: Float
  purchasing_part_id: ID
  reorder_quantity: Int
}

scalar Upload

input UpsertBundleInput {
  id: ID
  product_id: ID
  bundle_product_id: ID
  bundle_group_id: ID
  bundle_type_id: ID!
  quantity: Int!
}

input UpsertManufacturingInput {
  product_id: ID!
  process_time: Int
  buffer_time: Int
  cnc_program: String
  production_data: JSON
}

input UpsertPieceInput {
  id: ID
  product_id: ID
  piece_product_id: ID
  quantity: Int
}

input UpsertPiecePackInput {
  id: ID
  product_id: ID
  piece_pack_product_id: ID
  quantity: Int
}

input UpsertProductProductionChart {
  id: ID
  product_id: ID
  thickness: Float
  length: Float
  depth: Float
  final_thickness: Float
  final_length: Float
  final_depth: Float
  chop_quantity: Float
  glue_type: String
}

input UpsertShipmentBatchInput {
  id: ID
  shipping_method_id: ID!
  vrd_import_location_id: ID
  shipments: ShipmentBatchShipmentRelation
}

type User {
  id: ID!
  employee_id: ID
  username: String!
  first_name: String!
  last_name: String!
  email: String!
  phone: String
  employee_code: String
  sales_team_id: ID
  email_verified_at: DateTime
  created_at: DateTime!
  updated_at: DateTime
  deleted_at: DateTime
  trashed: Boolean!
  provider: String
  provider_id: ID
  avatar: String
  name: String!
  salesTeam: SalesTeam
  roles: [Role!]!
  permissions: [Permission!]!
  permissionNames: [String!]!

  """Get all the API keys associated with this user."""
  apiKeys: [ApiKey!]!
  connectedToGoogleAccount: Boolean!
}

input UserFilter {
  first_name: String
  last_name: String
  email: String
  trashed: Trashed
}

"""A paginated list of User items."""
type UserPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of User items."""
  data: [User!]!
}

input UserPermissionRelation {
  sync: [ID!]
  connect: [ID!]
}

input UserRoleRelation {
  sync: [ID!]
  connect: [ID!]
}

type VRDLocation {
  id: ID!
  name: String!
  location_type: VRDLocationType!
}

input VRDLocationFilter {
  location_type: VRDLocationType
}

enum VRDLocationType {
  building
  truck
  staging_bay
}

type VRDPackage {
  location: VRDLocation
  delivered: Boolean!
}

type ValidationMessage {
  message: String!
  level: ErrorLevel!
  blocksAutomatedShipping: Boolean
}

type Vendor {
  id: ID!
  name: String!
  phone: String
  fax: String
  addresses: [Address!]!
  attention: String
  email: String
  terms: String
  purchasing_default_tax: Float
  purchasing_rules: String
  dropship: Boolean
  mfg: Boolean
  parts: [VendorPart!]!
}

input VendorFilter {
  ids: [ID]
  name: String
  orderBy: [OrderByClause!]
}

"""A paginated list of Vendor items."""
type VendorPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of Vendor items."""
  data: [Vendor!]!
}

type VendorPart {
  id: ID!
  vendor_id: ID!
  vendor: Vendor
  name: String!
  description: String
  vendor_sku: String
  notes: String
  cost_account_id: ID
  costAccount: CostAccount
  department_id: ID
  department: Department
  purchase_price: Float
  purchasing_part_id: ID
  purchasing_part: PurchasingPart
  files: [File!]!
  reorder_quantity: Int
}

input VendorPartFilter {
  ids: [ID]
  name: String
  vendor_id: ID
  department_id: ID
  purchasing_part_id: [ID]
  orderBy: [OrderByClause!]
}

"""A paginated list of VendorPart items."""
type VendorPartPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of VendorPart items."""
  data: [VendorPart!]!
}

input VendorPartRelation {
  create: [CreateVendorPartInput!]
  update: [UpdateVendorPartInput!]
  delete: [ID!]
}

input VerifyEmailInput {
  token: String!
}

input VoeIdPayload {
  id: String!
  payload: String!
}

input VrdDeliveriesFilter {
  ids: [Int!]
  zip: String
}

type VrdDelivery {
  id: ID!
  vrd_section_id: ID!
  shipping_method_id: ID!
  zip: String!
  created_at: DateTime!
  updated_at: DateTime!
  VrdSection: VrdSection!
  ShippingMethod: ShippingMethod!
}

input VrdDeliveryInput {
  id: ID!
  vrd_section_id: ID
  shipping_method_id: ID
  zip: String
}

"""A paginated list of VrdDelivery items."""
type VrdDeliveryPaginator {
  """Pagination information about the list of items."""
  paginatorInfo: PaginatorInfo!

  """A list of VrdDelivery items."""
  data: [VrdDelivery!]!
}

type VrdSection {
  id: ID!
  vrd_rule_id: ID!
  name: String!
}

"""Dynamic WHERE conditions for queries."""
input WhereConditions {
  """The column that is used for the condition."""
  column: String

  """The operator that is used for the condition."""
  operator: SQLOperator = EQ

  """The value that is used for the condition."""
  value: Mixed

  """A set of conditions that requires all conditions to match."""
  AND: [WhereConditions!]

  """A set of conditions that requires at least one condition to match."""
  OR: [WhereConditions!]

  """
  Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  """
  HAS: WhereConditionsRelation
}

"""Dynamic HAS conditions for WHERE condition queries."""
input WhereConditionsRelation {
  """The relation that is checked."""
  relation: String!

  """The comparison operator to test against the amount."""
  operator: SQLOperator = GTE

  """The amount to test."""
  amount: Int = 1

  """Additional condition logic."""
  condition: WhereConditions
}

type WoodExceptions {
  quantity: Int!
  hasNotes: Boolean!
}

type WoodSampleProductTypesSetting {
  appSetting: AppSetting!
  selected: [OD1ProductType!]
  options: [OD1ProductType!]!
}

type WoodStationSamplesInstruction {
  order_number: ID!
  order_line_item_id: ID!
  order_line_items_description: String!
  od1_product_type_id: ID!
  wood_final_date: Date!
  order_line_items_name: String!
  finish_options_name: String
  production_item_ids: [ID!]!
  exceptions: WoodExceptions!
}

type WoodStationWorkInstruction {
  order_number: ID!
  order_line_item_id: ID!
  order_line_items_name: String!
  order_line_items_description: String!
  item_notes: String
  production_item_steps_final_wood: Int!
  production_item_steps_in_process: Int!
  production_item_ids: [ID!]!
  order_line_items_quantity: Int!
  wood_final_date: Date!
  final_length: String
  final_width: String
  final_height: String
  finish_options_name: String
  material_name: String
  exceptions: WoodExceptions!
}

type WoodStationWorkInstructionInProcessCnc {
  order_line_item_id: ID!
  order_number: ID!
  order_line_items_name: String!
  order_line_items_description: String!
  order_line_items_quantity: Int!
  wood_production_date: Date!
  production_item_steps_prc: Int!
  production_item_steps_in_process: Int!
  production_item_ids: [ID!]!
  final_length: String
  final_width: String
  final_height: String
  od1_product_type_id: ID!
  exceptions: WoodExceptions!
}

type WoodStationWorkInstructionInProcessMoulder {
  order_line_item_id: ID!
  order_number: ID!
  order_line_items_name: String!
  order_line_items_description: String!
  order_line_items_quantity: Int!
  wood_final_date: Date!
  production_item_steps_prc: Int!
  production_item_steps_in_process: Int!
  production_item_ids: [ID!]!
  final_length: String
  final_width: String
  final_height: String
  od1_product_type_id: ID!
  exceptions: WoodExceptions!
}

type WoodStationWorkInstructionInProcessTread {
  order_line_item_id: ID!
  order_number: ID!
  order_line_items_name: String!
  order_line_items_description: String!
  order_line_items_quantity: Int!
  wood_final_date: Date!
  production_item_steps_prc: Int!
  production_item_steps_in_process: Int!
  production_item_ids: [ID!]!
  final_length: String
  final_width: String
  final_height: String
  exceptions: WoodExceptions!
}

input leadTimeCreateInput {
  name: String!
  days: Int!
}

input leadTimeUpdateInput {
  id: ID!
  name: String
  days: Int
}

input leadTimesInput {
  ids: [ID!]
}

input metalBumpOutDashboardInput {
  metalProductionDate: Date!
}

